SECTION "ROM Bank $006", ROMX[$4000], BANK[$6]

    ; $4000
BITMAP_Font::
    ; The basic font tileset
    ; Mainly based off of ascii, but see charmap.asm
    INCBIN "autogenerated/assets/Font.tileset"

    ; Direct addresses to specific characters
        DEF BITMAP_Font_ArrowRight           EQU $40C0 ; ü°Ü
        DEF BITMAP_Font_ArrowDown            EQU $40D0 ; ü°á
        DEF BITMAP_Font_SpecimenJar          EQU $40E0 ; üß¥
        DEF BITMAP_Font_HollowStool          EQU $40F0 ; ü™ë
        DEF BITMAP_Font_Ring                 EQU $4100 ; üíç
        DEF BITMAP_Font_InfusedAnimite       EQU $4110 ; üåü
        DEF BITMAP_Font_Animite              EQU $4120 ; üí∞
        DEF BITMAP_Font_Spell                EQU $4130 ; üìú
        DEF BITMAP_Font_Drink                EQU $4140 ; ü•£
        DEF BITMAP_Font_UNKNOWNJar           EQU $4150 ; üçØ
        DEF BITMAP_Font_BalooLeaf            EQU $4160 ; üçÉ
        DEF BITMAP_Font_LuckFlower           EQU $4170 ; üåª
        DEF BITMAP_Font_BalooRootCloudFrond  EQU $4180 ; üå¥
        DEF BITMAP_Font_PlodSpnewMushroom    EQU $4190 ; üçÑ
        DEF BITMAP_Font_Gem                  EQU $41A0 ; üíé
        DEF BITMAP_Font_Relic                EQU $41B0 ; ‚ùì
        DEF BITMAP_Font_Energy               EQU $41C0 ; Œ£
        DEF BITMAP_Font_FatArrow             EQU $41D0 ; ‚óø
        DEF BITMAP_Font_Key                  EQU $41E0 ; üîë

        DEF BITMAP_Font_Space                EQU $4220
        DEF BITMAP_Font_Exclamation          EQU $4230

        DEF BITMAP_Font_Apostrophe           EQU $4270

        DEF BITMAP_Font_Comma                EQU $42C0
        DEF BITMAP_Font_Dash                 EQU $42D0
        DEF BITMAP_Font_Period               EQU $42E0

        DEF BITMAP_Font_0                    EQU $4300
        DEF BITMAP_Font_1                    EQU $4310
        DEF BITMAP_Font_2                    EQU $4320
        DEF BITMAP_Font_3                    EQU $4330
        DEF BITMAP_Font_4                    EQU $4340
        DEF BITMAP_Font_5                    EQU $4350
        DEF BITMAP_Font_6                    EQU $4360
        DEF BITMAP_Font_7                    EQU $4370
        DEF BITMAP_Font_8                    EQU $4380
        DEF BITMAP_Font_9                    EQU $4390
        DEF BITMAP_Font_Colon                EQU $43A0
        DEF BITMAP_Font_Slash                EQU $43B0 ; Semi-colon in real ascii

        DEF BITMAP_Font_Question             EQU $43F0

        DEF BITMAP_Font_A                    EQU $4410
        DEF BITMAP_Font_B                    EQU $4420
        DEF BITMAP_Font_C                    EQU $4430
        DEF BITMAP_Font_D                    EQU $4440
        DEF BITMAP_Font_E                    EQU $4450
        DEF BITMAP_Font_F                    EQU $4460
        DEF BITMAP_Font_G                    EQU $4470
        DEF BITMAP_Font_H                    EQU $4480
        DEF BITMAP_Font_I                    EQU $4490
        DEF BITMAP_Font_J                    EQU $44A0
        DEF BITMAP_Font_K                    EQU $44B0
        DEF BITMAP_Font_L                    EQU $44C0
        DEF BITMAP_Font_M                    EQU $44D0
        DEF BITMAP_Font_N                    EQU $44E0
        DEF BITMAP_Font_O                    EQU $44F0
        DEF BITMAP_Font_P                    EQU $4500
        DEF BITMAP_Font_Q                    EQU $4510
        DEF BITMAP_Font_R                    EQU $4520
        DEF BITMAP_Font_S                    EQU $4530
        DEF BITMAP_Font_T                    EQU $4540
        DEF BITMAP_Font_U                    EQU $4550
        DEF BITMAP_Font_V                    EQU $4560
        DEF BITMAP_Font_W                    EQU $4570
        DEF BITMAP_Font_X                    EQU $4580
        DEF BITMAP_Font_Y                    EQU $4590
        DEF BITMAP_Font_Z                    EQU $45A0

        DEF BITMAP_Font_a                    EQU $4610
        DEF BITMAP_Font_b                    EQU $4620
        DEF BITMAP_Font_c                    EQU $4630
        DEF BITMAP_Font_d                    EQU $4640
        DEF BITMAP_Font_e                    EQU $4650
        DEF BITMAP_Font_f                    EQU $4660
        DEF BITMAP_Font_g                    EQU $4670
        DEF BITMAP_Font_h                    EQU $4680
        DEF BITMAP_Font_i                    EQU $4690
        DEF BITMAP_Font_j                    EQU $46A0
        DEF BITMAP_Font_k                    EQU $46B0
        DEF BITMAP_Font_l                    EQU $46C0
        DEF BITMAP_Font_m                    EQU $46D0
        DEF BITMAP_Font_n                    EQU $46E0
        DEF BITMAP_Font_o                    EQU $46F0
        DEF BITMAP_Font_p                    EQU $4700
        DEF BITMAP_Font_q                    EQU $4710
        DEF BITMAP_Font_r                    EQU $4720
        DEF BITMAP_Font_s                    EQU $4730
        DEF BITMAP_Font_t                    EQU $4740
        DEF BITMAP_Font_u                    EQU $4750
        DEF BITMAP_Font_v                    EQU $4760
        DEF BITMAP_Font_w                    EQU $4770
        DEF BITMAP_Font_x                    EQU $4780
        DEF BITMAP_Font_y                    EQU $4790
        DEF BITMAP_Font_z                    EQU $47A0

    ; $5000
BITMAP_DamageText::
    ; The numbers that pop up when a creature takes damage
    INCBIN "autogenerated/assets/DamageText.tileset"

    ; $50B0
BITMAP_MenuAssets::
    ; Tiles used to draw a menu interface
    INCBIN "autogenerated/assets/MenuAssets.tileset"

    ; $5110
Menu_MainMenu_LoadGlyph::
    ; Copies the glyph's tileset into VRAM
    Set8 rVBK, $01
    Do_MemMov_V BITMAP_Menu_MainMenu_Glyph, Menu_MainMenu_VRAM_GLYPH_MAIN, (BITMAP_Menu_MainMenu_Glyph.End - BITMAP_Menu_MainMenu_Glyph)
    ret

    ; $5122
Menu_MainMenu_LoadAbilities::
    ; Copies the hero's 5 abilities' tilesets into VRAM
    Set8 rVBK, $01
    Do_MemMov_V BITMAP_Menu_MainMenu_Abilities_EnergyBand, Menu_MainMenu_VRAM_TONY_ABILITIES_ENERGYBAND, (BITMAP_Menu_MainMenu_Abilities_EyeOfTheStorm.End - BITMAP_Menu_MainMenu_Abilities_EnergyBand)
    ret

    ; $5134
Menu_MainMenu_LoadStatsHeaders::
    ; Call either Menu_MainMenu_LoadStatsHeaders.Creature or Menu_MainMenu_LoadStatsHeaders.Tony
    .Creature:
        ; Copies all 8 stats' tilesets into VRAM:
        ; First, do these 6 Strngth, Defense, Speed, Skill, Resist, Luck
        Set8 rVBK, $01
        Do_MemMov_V BITMAP_Menu_MainMenu_Stats_Strngth, $9150, (BITMAP_Menu_MainMenu_Stats_Luck.End - BITMAP_Menu_MainMenu_Stats_Strngth)
        ; Keep going
        .Tony::
            ; Copies 2 stats' tilesets into VRAM:
            ; Level, Exprnce
            Set8 rVBK, $01
            Do_MemMov_V BITMAP_Menu_MainMenu_Stats_Level, Menu_MainMenu_VRAM_RINGS_LEVEL, (BITMAP_Menu_MainMenu_Stats_Exprnce.End - BITMAP_Menu_MainMenu_Stats_Level)
            ret

    ; $5157
Menu_MainMenu_LoadTopTilemap::
    ; Given wMenu_MainMenu_CurrentMenu,
    ; It will load the preset tilemap for only the upper part of the StartScreen
    ; The menu ids Menu_MainMenu_ID_MAIN, Menu_MainMenu_ID_CLEAR, Menu_MainMenu_ID_UNUSED and Menu_MainMenu_ID_DEBUG
    ;    have null pointers $0000, but this is not verified in this function!
    ; All tilemaps are assumed to have a width of Menu_MainMenu_TOPTILEMAP_WIDTH = $14 and a height of Menu_MainMenu_TOPTILEMAP_HEIGHT = $0A (to fit in the top part)
    ; Inputs:
    ;   [wMenu_MainMenu_CurrentMenu]

    ; tilemap = [Menu_MainMenu_TopTilemapTable + 2*wMenu_MainMenu_CurrentMenu]
    xor a
    ld [rVBK], a
    ld a, [wMenu_MainMenu_CurrentMenu]
    add a
    ld c, a
    ld b, $00
    ld hl, Menu_MainMenu_TopTilemapTable
    add hl, bc
    ld a, [hl+]
    ld b, [hl]
    ld c, a

    ; Copy the tilemap file into the VRAM tilemap
    ld hl, WINDOW_COORD_01_00  ;Start at the second row
    ld d, Menu_MainMenu_TOPTILEMAP_HEIGHT
    .DoRow:
        ld e, Menu_MainMenu_TOPTILEMAP_WIDTH
        .DoTile:
            LdHLIBCI
            dec e
            jr nz, .DoTile
        dec d
        jr z, .Done ; inefficiency - why not "ret z"?
        push de
        ld de, SCRN_VX_B - Menu_MainMenu_TOPTILEMAP_WIDTH ; Jump to the next row
        add hl, de
        pop de
        jr .DoRow
    .Done:
    ret

    ; $5182
Menu_MainMenu_StringToTileset::
    ; Uses a string and places the correct tileset characters into VRAM
    ;
    ; It copies the letters one by from from BITMAP_Font to VRAM until end of string
    ; Inputs:
    ;   wMenu_MainMenu_StringToTileset_Length: length of string
    ;   wMenu_MainMenu_StringToTileset_Source: pointer to string
    ;   wMenu_MainMenu_StringToTileset_Dest: pointer to position in VRAM

    Set8 rVBK, $01
    .LoopLetter:
        ; Get the current character and increment the source
        FGet16 hl, wMenu_MainMenu_StringToTileset_Source
        Get8 e, hl+
        Set16 wMenu_MainMenu_StringToTileset_Source, hl

        ;Convert from char to bitmap position in BITMAP_Font by multiplying by $10
        ;Get the tileset address of the destination
        ld d, $00
        Sla16 de, $04
        FGet16 bc, wMenu_MainMenu_StringToTileset_Dest
        ld hl, BITMAP_Font
        add hl, de

        ; Copy the bitmap of the letter into the tileset
        ld d, $10
        .CopyLoop:
            LdBCIHLI
            dec d
            jr nz, .CopyLoop

        ; Update the dest and length vars
        FSet16 wMenu_MainMenu_StringToTileset_Dest, bc
        ld hl, wMenu_MainMenu_StringToTileset_Length

        ; Loop until end of string
        dec [hl]
        ret z
        jr .LoopLetter


; Menu_MainMenu_StringSetTable
; Menu_MainMenu_TopTilemapTable
DEF Menu_MainMenu_ID_MAIN EQU $00
DEF Menu_MainMenu_ID_CLEAR EQU $01
DEF Menu_MainMenu_ID_UNUSED EQU $02 ; This option is unused, but is left in to avoid breaking the code
DEF Menu_MainMenu_ID_SPELL EQU $03
DEF Menu_MainMenu_ID_ITEMS EQU $04
DEF Menu_MainMenu_ID_TONY_ EQU $05
DEF Menu_MainMenu_ID_RELIC EQU $06
DEF Menu_MainMenu_ID_RINGS EQU $07
DEF Menu_MainMenu_ID_ABILITY EQU $08
DEF Menu_MainMenu_ID_GLYPH EQU $09
DEF Menu_MainMenu_ID_DEBUG EQU $0A
DEF Menu_MainMenu_ID_INFUSED EQU $0B

MACRO StringAddressLength
    ; Automatically builds the string data used in Menu_MainMenu_StringSetTable
    ; Given a string, it will produce the string's address, followed by its length
    ; Usage:
    ;   StringAddressLength sStringName          -> The length is defined by the localaddres .End
    ;   StringAddressLength sStringName,LENGTH   -> The length is hardcoded
    dw \1
    IF _NARG == 2
        db \2
    ELSE
        db \1.End - \1
    ENDC
ENDM

    ; $51C1
Menu_MainMenu_TopTilemapTable::
    ; Contains a lookup table of tilemaps
    ; These tilemaps' dimensions are 20x10 and are used in the top half
    ; of the main menu
    dw $0000
    dw $0000
    dw $0000
    dw TILEMAP_Menu_MainMenu_Top_GenericList ; Menu_MainMenu_ID_SPELL
    dw TILEMAP_Menu_MainMenu_Top_GenericList ; Menu_MainMenu_ID_ITEMS
    dw TILEMAP_Menu_MainMenu_Top_Tony_
    dw TILEMAP_Menu_MainMenu_Top_GenericList ; Menu_MainMenu_ID_RELIC
    dw TILEMAP_Menu_MainMenu_Top_Rings
    dw TILEMAP_Menu_MainMenu_Top_Ability
    dw TILEMAP_Menu_MainMenu_Top_GlyphEmpty
    dw $0000
    dw TILEMAP_Menu_MainMenu_Top_InfusedList

    ; $51D9
Menu_MainMenu_StringSetTable::
    ; Contains a lookup table of string headers,
    ; Where each string header is formatted as follows:
    ;   dw  VRAM destination of strings
    ;   db  N = number of strings
    ;   N * {
    ;       dw  pointer to string
    ;       db  string length
    ;   }
    ; The strings will be sequentially copied into the destination
    dw STRINGSET_Menu_MainMenu_Main
    dw STRINGSET_Menu_MainMenu_Clear           ;  Called immediately after Main
    dw STRINGSET_Menu_MainMenu_Unknown        ; Calls Rings after
    dw STRINGSET_Menu_MainMenu_Spell
    dw STRINGSET_Menu_MainMenu_Items
    dw STRINGSET_Menu_MainMenu_Tony_           ; Called immediately after Clear
    dw STRINGSET_Menu_MainMenu_Relic
    dw STRINGSET_Menu_MainMenu_Rings
    dw STRINGSET_Menu_MainMenu_Ability
    dw STRINGSET_Menu_MainMenu_Glyph
    dw STRINGSET_Menu_MainMenu_Debug        ; Called only when entering the screen - used to help the developer build a menu
    dw STRINGSET_Menu_MainMenu_InfusedList

    ; $51F1
STRINGSET_Menu_MainMenu_Main::
    ; The absolute addresses of these strings are also defined in mainmenu_include.asm
    dw $8860          ;Paste destination
    db $08          ;Number of strings
    StringAddressLength sMenu_MainMenu_Tony_
    StringAddressLength sMenu_MainMenu_Spell
    StringAddressLength sMenu_MainMenu_Rings
    StringAddressLength sMenu_MainMenu_Items
    StringAddressLength sMenu_MainMenu_Glyph
    StringAddressLength sMenu_MainMenu_Energyicon
    StringAddressLength sMenu_MainMenu_Animiteicon
    StringAddressLength sMenu_MainMenu_Numbers

    ; $520C
STRINGSET_Menu_MainMenu_Clear::
    dw $8C40          ;Paste destination
    db $01          ;Number of strings
    StringAddressLength sMenu_MainMenu_Debug, $1A ; The string length is $1A

    ; $5212
STRINGSET_Menu_MainMenu_Unknown::
STRINGSET_Menu_MainMenu_Spell::
    dw $8800          ;Paste destination
    db $01          ;Number of strings
    StringAddressLength sMenu_MainMenu_Blank_ExSpell ; "This used to say "Spell", but was replaced with a blank space which is not visible
    ;StringAddressLength sMenu_MainMenu_Book  ; This used to be in the Spell menu, but was removed even before the alpha version of the game

    ; $5218
STRINGSET_Menu_MainMenu_Items::
    dw $8800          ;Paste destination
    db $01          ;Number of strings
    StringAddressLength sMenu_MainMenu_Blank_ExItem1 ; This used to say "Item", but was replaced with a blank space which is not visible
    ;StringAddressLength sMenu_MainMenu_List  ; This used to be in the Item menu, but was removed even before the alpha version of the game

    ; $521E
STRINGSET_Menu_MainMenu_InfusedList::
    dw $8800          ;Paste destination
    db $01          ;Number of strings
    StringAddressLength sMenu_MainMenu_Blank_ExItem2 ; This used to say "Item", but was replaced with a blank space which is not visible

    ; $5224
STRINGSET_Menu_MainMenu_Tony_::
    ; The absolute addresses of these strings are also defined in mainmenu_include.asm
    dw $8C40          ;Paste destination
    db $02          ;Number of strings
    StringAddressLength sMenu_MainMenu_Lvl_ ; This string is copied but not used
    StringAddressLength sMenu_MainMenu_Exp ; This string is copied but not used

    ; $522D
STRINGSET_Menu_MainMenu_Relic::
    dw $8B00          ;Paste destination
    db $01          ;Number of strings
    StringAddressLength sMenu_MainMenu_Blat ; Blat is a placeholder text which is not visible

    ; $5233
STRINGSET_Menu_MainMenu_Rings::
    ; The absolute addresses of these strings are also defined in mainmenu_include.asm
    dw $8B50          ;Paste destination
    db $04          ;Number of strings
    StringAddressLength sMenu_MainMenu_Lvl_ ; This string is copied but not used
    StringAddressLength sMenu_MainMenu_Exp ; This string is copied but not used
    StringAddressLength sMenu_MainMenu_Ability
    StringAddressLength sMenu_MainMenu_Relicicon

    ; $5242
STRINGSET_Menu_MainMenu_Ability::
    ; The absolute addresses of these strings are also defined in mainmenu_include.asm
    dw $8AB0          ;Paste destination
    db $01          ;Number of strings
    StringAddressLength sMenu_MainMenu_Ability__

    ; $5248
STRINGSET_Menu_MainMenu_Glyph::
STRINGSET_Menu_MainMenu_Debug::
    ; When opening start screen
    ; All the available space ($55 bytes) as overwritten with numbers so that
    ; if the developer wants to make a new menu screen, he sees the numbers
    ; and can easily assign the tileids to the right places
    ; This string should never be exposed to the user
    dw $8AB0          ;Paste destination
    db $01          ;Number of strings
    StringAddressLength sMenu_MainMenu_Debug


    ; $524E
sMenu_MainMenu_EmptyRelic::
    db "Empty       "
    .End

    ; $525A
sMenu_MainMenu_Tony_::
    db "Tony "
    .End

    ; $525F
sMenu_MainMenu_Spell::
    db "Spell"
    .End

    ; $5264
sMenu_MainMenu_Rings::
    db "Rings"
    .End

    ; $5269
sMenu_MainMenu_Items::
    db "Items"
    .End

    ; $526E
sMenu_MainMenu_Glyph::
    db "Glyph"
    .End

    ; $5273
sMenu_MainMenu_Energyicon::
    db "Œ£"
    .End

    ; $5274
sMenu_MainMenu_Animiteicon::
    db "üí∞"
    .End

    ; $5275
sMenu_MainMenu_Numbers::
    ; These numbers are used in the tilemap for dynamic numbers
    db "0123456789"
    .End

    ; $527F
sMenu_MainMenu_InfusedList::
    db "üåüList"
    .End

    ; $5284
sMenu_MainMenu_Save::
    db "Save"
    .End
    ; $5288
sMenu_MainMenu_SaveBlank::
    ; Previously instead of the Save option, when in a map, you could use this to teleport back (like using the Awl) when you were not in the overworld
    ; Now this is used to hide the Save option
    db "     "
    .End

    ; $528D
sMenu_MainMenu_Lvl_::
    ; This string is copied but not used
    db "Lvl:"
    .End

    ; $5291
sMenu_MainMenu_Exp::
    ; This string is copied but not used
    db "Exp"
    .End

    ; $5294
sMenu_MainMenu_Blank_ExSpell::
    db " "
    .End
    ; $5295
    ; Unused
    db "pell"
    ; $5299
sMenu_MainMenu_Book::
    ; This string is unused. It was originally intended to be used in the Spell menu
    ; but was removed even before the alpha version
    db "Book"
    .End

    ; $529D
sMenu_MainMenu_Blank_ExItem1::
    db " "
    .End
    ; $529E
    ; Unused
    db "tem "

    ; $52A2
sMenu_MainMenu_List::
    ; This string is unused. It was originally intended to be used in the Item menu
    ; but was removed even before the alpha version
    db "List"
    .End

    ; $52A6
sMenu_MainMenu_Blank_ExItem2::
    db " "
    .End
    ; $52A7
    ; Unused
    db "tem "

    ; $52AB
sMenu_MainMenu_Ability::
    db "Ability"
    .End

    ; $52B2
sMenu_MainMenu_Relicicon::
    db "‚ùì"
    .End

    ; $52B3
sMenu_MainMenu_Ability__::
    db "Ability  "
    .End

    ; $52BC
sMenu_MainMenu_Blat::
    ; Blat was the internal placeholder name
    db "Blat"
    .End

    ; $52C0
    ; todo
    db "Which ring do youwant to act on?LvlEXBuySelüí∞Donex‚óøItemsSplRic‚óøDone"

    ; $5302
sMenu_Music_ChooseASong::
    db "Choose a Song"
    .End
sMenu_Music_ASelects::
    db "A-Selects"
    .End
sMenu_Music_BExits::
    db "B-Exits"
    .End
sMenu_Music_FatArrow::
    db "‚óø"
    .End

    ; $5320
    ; todo
    db "TonyCostüíçüåüüí∞‚óøLVEX"

    ; $5330
sMenu_MainMenu_Debug::
    ; This string should never be exposed to the user
    ; It is used for debugging for the developer
    db "0123456789"
    db "0123456789"
    db "01X3456789" ; X = 22. Also, this string is truncated after "5" in STRINGSET_Menu_MainMenu_Clear
    db "0123456789"
    db "0123456789"
    db "0123456789"
    db "0123456789"
    db "0123456789"
    db "01234"
    .End


CreatureName_SummonMenuLoadNames::
    ; Loads the names of the dream creatures in Tony's Summon menu during battle
    ; Inputs:
    ;   wMenu_SelectedRingIndex - 0 (for the first 5 creatures) or 5 (for the last 5 creatures)
    SwitchRAMBank BANK("WRAM BATTLE")
    ld a, [wMenu_SelectedRingIndex]
    ld hl, wBattle_SelectedRingIndex
    ld [hl], a
    FOR loop, 0, 5
        IF loop != 0
            ; Increment the selected ring by 1, except for the first loop
            ld hl, wBattle_SelectedRingIndex
            inc [hl]
            ld a, [hl]
        ENDC
        ; Check if the ring is currently in play or not
        ld c, a
        ld b, $00
        ld hl, wBattle_UsedRings
        add hl, bc
        ld a, [hl]
        cp BATTLE_USEDRINGS_ALIVE
        jp z, .Indent\@ ; inefficiency - jr could be used
        .NoIndent\@:
            ; Ring is not in play, so paste the creature name as normal
            Menu_TextCreatureSetup $01, BATTLE_MENU_VRAM_SUMMONNAME{u:loop}, BATTLE_MENU_TILEMAP_SUMMONNAME{u:loop}
            jp .Finally\@ ; inefficiency - jr could be used
        .Indent\@:
            ; Ring is in play, so indent the destination by 1 tile to the right and then paste the creature name
            Menu_TextCreatureSetup $01, BATTLE_MENU_VRAM_SUMMONNAME{u:loop}, BATTLE_MENU_TILEMAP_SUMMONNAME{u:loop} + 1
        .Finally\@:
        Menu_TextUpdateLoop
    ENDR
    ret


CreatureName_CopyToDest::
    ; Given a dream creature index, the creature's name will be stored in
    ; the buffer indicated by [wBattle_CopyBuffer_Destination]
    ; Arguments:
    ;   wBattle_CopyBuffer_ListIndex - the creatures' id
    ; Output:
    ;   [wBattle_CopyBuffer_Destination] = Creature's name
    Get8 b, wBattle_CopyBuffer_ListIndex
    cp CreatureID_Null
    jr nz, .NotNull
    .Null:
        ld hl, CreatureName_Null
        jr .GetBufferAddress
    .NotNull:
        ld c, CreatureName_SIZE
        call Math_Mult
        ld bc, CreatureName_Table
        add hl, bc
    .GetBufferAddress:
    Get16 bc, wBattle_CopyBuffer_Destination
    ld d, CreatureName_SIZE
    .CopyNameLoop:
        LdBCIHLI
        dec d
        jr nz, .CopyNameLoop
    ret

    ; $5A87
Call_006_5A87::
    ; TODO unknown
    FGet16 bc, wBattle_CopyBuffer_Destination
    FGet16 hl, wBattle_CopyBuffer_Source
    ld d, $22
    .Loop:
        LdBCIHLI
        dec d
        jr nz, .Loop
    ret


CreatureName_Null::
    db "          " ; CreatureID_Null

CreatureName_Table::
    db "Abaquist  "
    db "Agovo     "
    db "Alaban    "
    db "Arbolit   "
    db "Arboll    "
    db "Ayebaw    "
    db "Bhatar    "
    db "Bisiwog   "
    db "BlackAgovo"
    db "Bolt Hyren"
    db "Borgor    "
    db "Brub      "
    db "Bwill     "
    db "Cave Hyren"
    db "CaveRudwot"
    db "Chaos Jile"
    db "CoralHyren"
    db "Core Grag "
    db "Core Hyren"
    db "DarkAyebaw"
    db "DarkVellup"
    db "Deep Hyren"
    db "Diobor    "
    db "Drakan    "
    db "DryteFiend"
    db "Eebit     "
    db "Epik      "
    db "FlameHyren"
    db "Furok     "
    db "GhostBwisp"
    db "GiantKorit"
    db "Graw      "
    db "Grax      "
    db "Gum Gum   "
    db "Hook Wing "
    db "Jingjack  "
    db "Karak     "
    db "Kazor     "
    db "Kelthet   "
    db "Kletch    "
    db "Koil      "
    db "Lava Aq   "
    db "LavaArboll"
    db "LavaBalmnt"
    db "Leaf Chogo"
    db "Leaf Hyren"
    db "MagmaHyren"
    db "Megathan  "
    db "Mush Hyren"
    db "Orathan F "
    db "Orish     "
    db "Ormagon   "
    db "Orpus     "
    db "Paralit   "
    db "Parmalag  "
    db "Platheus  "
    db "Plith     "
    db "Porkuslime"
    db "Quor      "
    db "Rabbage   "
    db "Raxis     "
    db "Rudwot    "
    db "Sabreback "
    db "Sarbil    "
    db "Sea Jile  "
    db "ShadwKarak"
    db "ShadwVinoc"
    db "Sharbloot "
    db "Shryque   "
    db "Sphor     "
    db "Spindle   "
    db "ThundrHyrn"
    db "TimberHyrn"
    db "Treebit   "
    db "Tusk Bwisp"
    db "Twee      "
    db "Vashp     "
    db "Vellup    "
    db "Vile Yogu "
    db "Vinoc     "
    db "Vulbor    "
    db "Wasperine "
    db "Weebat    "
    db "Weebo     "
    db "Xyx       "
    db "Yvohcna   "
    db "PlAcEhOlDr"
    db "PlAcEhOlDr"
    db "Tony      "
    db "Togoth    "
    db "Ogar      "
    db "Korremar  "
    db "Warrada   "
    db "Korg      "
    db "Zet       "
    db "Morag     "
    db "Agram     "
    db "Agram     "
    db "Agram     "
    db "ShadowMagi"
    db "ShadowMagi"
    db "ShadowMagi"
    db "ShadowMagi"
    db "ShadowMagi"
    db "ShadowMagi"
    db "ShadowMagi"
    db "ShadowMagi"
    db "Salafy    "
    db "          " ; NoMagi

    ; $5EE8
Menu_MainMenu_SetTilemap2DigitNumber:
    ; Takes a, converts it into a 2 digit number and writes it in the tilemap,
    ; assuming that the numbers 0123456789 are located at address Menu_MainMenu_TILEID_NUMBERS
    ; Arguments:
    ;   a = Number
    ;   hl = destination tilemap
    ld e, a
    ld d, $00
    call Math_ConvertNumberToDigits
    ld a, [wX10]
    add Menu_MainMenu_TILEID_NUMBERS
    ld [hl+], a
    ld a, [wX1]
    add Menu_MainMenu_TILEID_NUMBERS
    ld [hl+], a
    ret

    ; $5EFB
Menu_MainMenu_BackupVRAMObjectsChars::
    ; Backs up vObjectsChars (01:8E00 - 01:9000) temporarily in wMenu_MainMenu_ObjectsCharsBuffer
    Set8 rVBK, $01
    ld bc, wMenu_MainMenu_ObjectsCharsBuffer
    ld hl, vObjectsChars
    call Menu_MainMenu_Copy200Bytes
    ret

    ; $5F0A
Menu_MainMenu_DrawAttrmapTop:
    ; Fixes the attrmap for the top of the menu
    ; First, it resets the attrmap to a normal state
    ; Then, it applies the X/Y flips unique to each top menu
    ; Note that when the menu is loaded for the first time by pressing start, this function is not run. Therefore, the Tony top screen should not
    ; have any attrmap transformations, or alternatively this function could be added to the Menu_MainMenu_Open function
    ; Inputs:
    ;   wMenu_MainMenu_CurrentMenu - the top screen that is being displayed

    ; Reset flipped arrows
    ; bug:
    ; 3 of the reset locations are unused. In the alpha version, the arrows were location in the bottomleft and bottomright corner, and not on the top/bottom
    ; The resetting also fails to fix the arrow in the Rings tab located at WINDOW_COORD_0A_09 and WINDOW_COORD_0A_0A. Luckily, this doesn't cause any graphical glitches
    Set8 rVBK, $01
    ld a, $0F   ;Palette 7
    ld [WINDOW_COORD_01_0A], a ;Reset ArrowUp
    ld [WINDOW_COORD_09_12], a ;Reset bottomright corner (unused)
    ld [WINDOW_COORD_09_09], a ;Reset ArrowDown (left)
    ld [WINDOW_COORD_0A_02], a ;Reset bottomleft corner (unused)
    ld [WINDOW_COORD_09_0A], a ;Reset ArrowDown (right)
    ld [WINDOW_COORD_0A_12], a ;Reset bottomright corner (unused)
    ; This above fails to fix the attrmap of FlipFatArrowsLower. Maybe the arrow used to be in the bottomleft and bottomright corner?
    ld a, [wMenu_MainMenu_CurrentMenu]
    cp Menu_MainMenu_ID_SPELL
    jr z, .FlipFatArrowsHigher
    cp Menu_MainMenu_ID_ITEMS
    jr z, .FlipFatArrowsHigher
    cp Menu_MainMenu_ID_RELIC
    jr z, .FlipFatArrowsHigher
    cp Menu_MainMenu_ID_INFUSED
    jr z, .FlipFatArrowsHigher
    cp Menu_MainMenu_ID_RINGS
    jr z, .FlipFatArrowsLower
    cp Menu_MainMenu_ID_GLYPH
    jr z, .GlyphAttrmap
    cp Menu_MainMenu_ID_TONY_ ; Quitting the Glyph, so we have to reset the entire attrmap
    jr z, .ResetAll
    ret
    .FlipFatArrowsHigher:
        ; Top arrow on row $01
        ; Bottom arrow on row $09
        Set8 WINDOW_COORD_01_0A, $2F ; Up
        Set8 WINDOW_COORD_09_09, $4F ; Down (left)
        Set8 WINDOW_COORD_09_0A, $6F ; Down (right)
    .FlipFatArrowsLower:
        ; Top arrow on row $01
        ; Bottom arrow on row $0A
        Set8 WINDOW_COORD_01_0A, $2F ; Up
        Set8 WINDOW_COORD_0A_09, $4F ; Down (left)
        Set8 WINDOW_COORD_0A_0A, $6F ; Down (right)
        ret
    .GlyphAttrmap:
        ; Copy the glyph's attrmap
        ld hl, WINDOW_COORD_02_04
        ld bc, ATTRMAP_GlyphEmpty ; $0C wide, $08 tall
        Set8 wMenu_MainMenu_TempIndex, $08
        .GlyphRowLoop:
            ld d, $0C
            .GlyphTileLoop:
                LdHLIBCI
                dec d
                jr nz, .GlyphTileLoop
            ld a, [wMenu_MainMenu_TempIndex]
            dec a
            jr z, .GlyphLoopFinished
            ld [wMenu_MainMenu_TempIndex], a
            ld de, SCRN_VX_B - $0C
            add hl, de
            jr .GlyphRowLoop
        .GlyphLoopFinished:

       ; The glyph is loaded by default as empty! We need to modify the tilemap to add the core stones as needed
        Battery_On
        Battery_SetBank "XRAM Gamestate"

        Get8 b, xGlyphState
        Battery_Off

        ; If no Core stones, end
        ld a, b
        cp $02
        ret c

        ; Fix Core stone 1
        Set8 WINDOW_COORD_06_0A, $0F

        ; Core stone 2 does not need fixing
        ld a, b
        cp $04
        ret c

        ; Fix Core stone 3
        Set8 WINDOW_COORD_07_0A, $0F
        ld a, b
        cp $05
        ret c

        ; Fix Core stone 4
        Set8 WINDOW_COORD_08_0A, $0F
        ld a, b
        cp $06
        ret nz

        ; Fix Core stone 5
        ld bc, ATTRMAP_GlyphCoreStone5
        call Menu_MainMenu_GlyphCoreStone5
        ret

    .ResetAll:
        jp Menu_MainMenu_BottomMenuInit.InitAttrMap


    ; $5FC2
Menu_MainMenu_BottomMenuInit::
    ; Programmically writes the tilemap and attrmap for the
    ; bottom part of the main menu, as well as the top row (border)
    ;
    ; When the top part of the menu is loaded, the rows $01 to $0A inclusive are completely rewritten, meaning
    ; that we don't have to initialize these rows
    ; 
    ; This seems a bit excessive - it probably would have been better to have saved a base tile/attrmap
    ; to load, instead of programmically generating the borders
    ;
    ; Inputs:
    ;   None
    ; Outputs:
    ;   [wTextbox_WX] -> 7
    ;   [wTextbox_WY] -> 0

    ; Set the whole $9C00 screen to blank by setting the first $12 rows to Textbox_TILEID_BLANK
    xor a
    ld [rVBK], a
    ld bc, WINDOW_COORD_11_13 - WINDOW_COORD_00_00 ; Bug - the constant value should be incremented by 1 to blank the entire menu. As it stands, coordinate (11,13) is not blanked
    ld hl, WINDOW_COORD_00_00
    .LoopT:
        ld a, Textbox_TILEID_BLANK
        ld [hl+], a
        Dec16Loop bc, .LoopT

    ; Put corner tiles
    ld a, Textbox_TILEID_BORDER_CORNER
    ld [WINDOW_COORD_00_00], a ;Topleft corner
    ld [WINDOW_COORD_00_13], a ;Topright corner
    ld [WINDOW_COORD_0B_00], a ;Middleleft corner
    ld [WINDOW_COORD_0B_13], a ;Middleright corner
    ld [WINDOW_COORD_11_00], a ;Bottomleft corner
    ld [WINDOW_COORD_11_13], a ;Bottomright corner

    ; Draw the 3 horizontal lines
    Menu_MainMenu_SetTilemapHorizontal Textbox_TILEID_BORDER_TOP, WINDOW_COORD_11_01, WINDOW_COORD_11_13
    Menu_MainMenu_SetTilemapHorizontal Textbox_TILEID_BORDER_TOP, WINDOW_COORD_0B_01, WINDOW_COORD_0B_13
    Menu_MainMenu_SetTilemapHorizontal Textbox_TILEID_BORDER_TOP, WINDOW_COORD_00_01, WINDOW_COORD_00_13

    ; Draw the two vertical lines of the bottom half
    Menu_MainMenu_SetTilemapVertical Textbox_TILEID_BORDER_RIGHT, WINDOW_COORD_0C_00, WINDOW_COORD_11_00
    Menu_MainMenu_SetTilemapVertical Textbox_TILEID_BORDER_RIGHT, WINDOW_COORD_0C_13, WINDOW_COORD_11_13

    ; Write "Tony ", "Spell", "Rings", "Items", "Glyph" in the menu
    xor a
    ld [rVBK], a
    Do_Menu_MainMenu_SetTilemapString Menu_MainMenu_TILEID_TONY_, WINDOW_COORD_0C_02, (sMenu_MainMenu_Tony_.End - sMenu_MainMenu_Tony_)
    Do_Menu_MainMenu_SetTilemapString Menu_MainMenu_TILEID_SPELL, WINDOW_COORD_0D_02, (sMenu_MainMenu_Spell.End - sMenu_MainMenu_Spell)
    Do_Menu_MainMenu_SetTilemapString Menu_MainMenu_TILEID_RINGS, WINDOW_COORD_0E_02, (sMenu_MainMenu_Rings.End - sMenu_MainMenu_Rings)
    Do_Menu_MainMenu_SetTilemapString Menu_MainMenu_TILEID_ITEMS, WINDOW_COORD_0F_02, (sMenu_MainMenu_Items.End - sMenu_MainMenu_Items)
    Do_Menu_MainMenu_SetTilemapString Menu_MainMenu_TILEID_GLYPH, WINDOW_COORD_10_02, (sMenu_MainMenu_Glyph.End - sMenu_MainMenu_Glyph)

    ; If the hero does not have the glyph, erase the text "Glyph" with "     "
    Battery_On
    Battery_SetBank "XRAM Gamestate"
    ld a, [xGlyphState]
    and a
    jr nz, .Skip
    .EraseGlyph:
        ld hl, WINDOW_COORD_10_02
        ld a, Textbox_TILEID_BLANK
        ld d, (sMenu_MainMenu_Glyph.End - sMenu_MainMenu_Glyph)
        .EraseGlyphTiles:
            ld [hl+], a
            dec d
            jr nz, .EraseGlyphTiles
    ; Bug - .Skip should be before Battery_Off
    Battery_Off
    .Skip:

    ; Write "üåüList" and "Save"
    Do_Menu_MainMenu_SetTilemapString Menu_MainMenu_TILEID_INFUSEDLIST, WINDOW_COORD_10_0E, (sMenu_MainMenu_InfusedList.End - sMenu_MainMenu_InfusedList)
    Do_Menu_MainMenu_SetTilemapString Menu_MainMenu_TILEID_SAVE, WINDOW_COORD_0F_0E, (sMenu_MainMenu_Save.End - sMenu_MainMenu_Save)

    ; Write the Energy symbol and : for Tony's energy
    ; Write the Animite symbol for Tony's money
    Set8 WINDOW_COORD_0D_0B, Menu_MainMenu_TILEID_ENERGYICON
    Set8 WINDOW_COORD_0C_0D, Menu_MainMenu_TILEID_ANIMITEICON
    Set8 WINDOW_COORD_0D_0F, Menu_MainMenu_TILEID_COLON

    ; Write the hero's current money
    Battery_SetBank "XRAM Gamestate"
    Battery_On
    FGet16 de, xMoney
    Battery_Off
    call Math_ConvertNumberToDigits
    ld hl, WINDOW_COORD_0C_0E
    ld d, Menu_MainMenu_TILEID_NUMBERS
    call Menu_MainMenu_SetTilemap3DigitNumber

    ; Write the hero's current energy and max energy
    Battery_SetBank "XRAM Creatures"
    Battery_On
    FGet16_BigEndian de, xCreature_00_Hero.CurEnergy
    call Math_ConvertNumberToDigits
    ld hl, WINDOW_COORD_0D_0C
    ld d, Menu_MainMenu_TILEID_NUMBERS
    call Menu_MainMenu_SetTilemap3DigitNumber ;Current energy

    FGet16_BigEndian de, xCreature_00_Hero.MaxEnergy
    call Math_ConvertNumberToDigits
    ld hl, WINDOW_COORD_0D_10
    ld d, Menu_MainMenu_TILEID_NUMBERS
    call Menu_MainMenu_SetTilemap3DigitNumber ;Max energy
    Battery_Off

    .InitAttrMap:
    ; Now that the tilemap is satisfactory, let's prepare the attrmap

    ; Set the whole $9C00 screen to the default attribute setting
    Set8 rVBK, $01
    ld d, $0F ; Palette 7, VRAM 1 
    ld bc, (WINDOW_COORD_11_13 - WINDOW_COORD_00_00) + 1
    .LoopA:
        ld hl, WINDOW_COORD_00_00 - 1
        add hl, bc ; Kind of a weird way of doing it but it works
        ld [hl], d
        Dec16Loop bc, .LoopA

    ; YFlip the bottom horizontal line
    ld a, $4F    ;Yflip, VRAM 1, Palette 7
    ld d, (WINDOW_COORD_11_13 - WINDOW_COORD_11_01)
    ld hl, WINDOW_COORD_11_01
    .LoopY:
        ld [hl+], a
        dec d
        jr nz, .LoopY

    ; XFlip the left vertical line (both the top and bottom part)
    ; From WINDOW_COORD_01_00 to WINDOW_COORD_10_00
    ; Technically the upper half of this vertical line doesn't necessarily need to be set because
    ; it will be overwritten when the top part of the menu is loaded
    ld bc, (WINDOW_COORD_10_00 - WINDOW_COORD_00_00)/SCRN_VX_B
    .LoopB:
        ld hl, WINDOW_COORD_00_00
        push bc
        Sla16 bc, $05 ;Multiply by $20 = SCRN_VX_B
        add hl, bc
        ld a, $2F    ;Xflip, VRAM 1, Palette 7
        ld [hl+], a
        pop bc
        dec c
        jr nz, .LoopB

    ; Set the attributes of the corner tiles
    ld a, $2F    ; Xflip, VRAM 1, Palette 7
    ld [WINDOW_COORD_00_00], a ; Topleft corner
    ld [WINDOW_COORD_0B_00], a ; Topmiddle corner
    Set8 WINDOW_COORD_11_13, $4F    ; Bottomright corner <- Yflip, VRAM 1, Palette 7
    Set8 WINDOW_COORD_11_00, $6F    ; Bottomleft corner <- X+Yflip, VRAM 1, Palette 7
    ; Topright corner is already $0F (no flips)

    ; Align the textbox frame
    xor a
    ld [wTextbox_WY], a
    Set8 wTextbox_WX, $07
    ret

    ; $615F
Menu_MainMenu_EraseTonyAbility::
    ; Hide an ability in Tony's menu
    ; Inputs:
    ;   hl = address of the topleft corner of the icon in the tilemap
    ; Outputs:
    ;   Icon is hidden by replacing the icon with Textbox_TILEID_BLANK
    ld a, Textbox_TILEID_BLANK
    ld de, SCRN_VX_B - $03 ;row offset
    ld [hl+], a
    ld [hl+], a
    ld [hl+], a
    add hl, de
    ld [hl+], a
    ld [hl+], a
    ld [hl+], a
    add hl, de
    ld [hl+], a
    ld [hl+], a
    ld [hl+], a
    ret

    ; $6170
Menu_MainMenu_Copy200Bytes::
    ; Copies $200 bytes from hl to bcs
    ; Used to copy vObjectsChars to wMenu_MainMenu_ObjectsCharsBuffer and back
    ld d, $20
    .NumberOfTilesLoop:
        ld e, $10
        .SingleTileLoop:
            LdBCIHLI
            dec e
            jr nz, .SingleTileLoop
        dec d
        jr nz, .NumberOfTilesLoop
    ret

    ; $617E
Menu_MainMenu_SetRelicString:
    ; Given a creature struct, get the name of a relic (the first letter is stripped since it's assumed to be ‚ùì)
    ; Write the tilesets corresponding to the name
    ; Inputs:
    ;   hl = Base address of the creature struct
    ;   bc = Relative offset to (.Relic0) or (.Relic1)
    ;   wMenu_MainMenu_StringToTileset_Dest = Destination to write the tilesets

    ; Get the relic's id
    add hl, bc
    ld bc, wMenu_Battle_TableRowBuffer ; temporary buffer containing relic id
    Battery_SetBank "XRAM Creatures"
    Battery_On
    LdBCIHLI
    Battery_Off

    ; Make sure it's not the null relic
    ld a, [wMenu_Battle_TableRowBuffer]
    and a
    jr z, .NullRelic      ;Null relic
    .DefinedRelic:
        ; Get the relic data
        ld [wBattle_CopyBuffer_ListIndex], a
        ld bc, wMenu_Battle_TableRowBuffer ; We re-use the buffer for a second purpose - getting the relic data
        FSet16 wBattle_CopyBuffer_Destination, bc
        Do_CallForeign Relic_GetDataFromID
        .Finally:
            ; Now that we have the relic data, we can take the name and write it into the tileset
            ld bc, wMenu_Battle_TableRowBuffer.Relic_Name + 1  ; Skip the first letter ‚ùì
            FSet16 wMenu_MainMenu_StringToTileset_Source, bc
            Set8 wMenu_MainMenu_StringToTileset_Length, (wMenu_Battle_TableRowBuffer.Relic_NameEnd - (wMenu_Battle_TableRowBuffer.Relic_Name + 1))
            call Menu_MainMenu_StringToTileset
            ret
    .NullRelic:
        ; Manually insert the string sMenu_MainMenu_EmptyRelic ("Empty       ") into the buffer instead of loading from the datatable
        ld bc, wMenu_Battle_TableRowBuffer.Relic_Name + 1 ; Skip the first letter
        ld hl, sMenu_MainMenu_EmptyRelic
        ld d, (wMenu_Battle_TableRowBuffer.Relic_NameEnd - (wMenu_Battle_TableRowBuffer.Relic_Name + 1))
        .CopyEmpty:
            LdBCIHLI
            dec d
            jr nz, .CopyEmpty
        jr .Finally

    ; $61D2
Menu_MainMenu_RestoreVRAMObjectsChars::
    ; Restores vObjectsChars (01:8E00 - 01:9000) from wMenu_MainMenu_ObjectsCharsBuffer
    Set8 rVBK, $01
    ld hl, wMenu_MainMenu_ObjectsCharsBuffer
    ld bc, vObjectsChars
    call Menu_MainMenu_Copy200Bytes
    ret

    ; $61E1
Menu_MainMenu_SetTilemap3DigitNumber::
    ; Pastes the 3 digits of a number into a tilemap with all tiles having an offset of d
    ; Arguments:
    ;   d -> Offset pointing to tile "0" in a tileset string "0123456789"
    ;   hl -> Destination
    ;   wX1, wX10, wX100 -> The number in individual digits
    ld a, [wX100]
    add d
    ld [hl+], a
    ld a, [wX10]
    add d
    ld [hl+], a
    ld a, [wX1]
    add d
    ld [hl+], a
    ret

    ; $61F1
Menu_MainMenu_DrawCurrentTop::
    ; Loads all the strings sequentially pointed to in Menu_MainMenu_StringSetTable into tilesets
    ; Then, loads the tilemaps if indicated
    ; Then, loads the custom data if indicated
    ;
    ; Inputs:
    ;   Menu_MainMenu_StringSetTable: Loads the Xth element into VRAM
    ;
    ; Outputs:
    ;       If Menu_MainMenu_ID_MAIN is selected, it will immediately do Menu_MainMenu_ID_CLEAR after
    ;       If Menu_MainMenu_ID_CLEAR is selected, it will immediately do Menu_MainMenu_ID_TONY_ after
    ;       If Menu_MainMenu_ID_UNUSED is selected, it will immediately do Menu_MainMenu_ID_RINGS after (unused transformation)
    ;       Otherwise, if anything except Initialization is selected, it will load the tilemap corresponding to the index
    ;       It will then run functions to retrieve the SRAM information

    ; First, get the StringSetTable corresponding to the currently selected menu:
    ; [Menu_MainMenu_StringSetTable + 2*wMenu_MainMenu_CurrentMenu]
    ld hl, Menu_MainMenu_StringSetTable
    ld a, [wMenu_MainMenu_CurrentMenu]
    add a
    ld e, a
    ld d, $00
    add hl, de
    DerefHL

    ; Read the StringSet header
    ; wMenu_MainMenu_StringToTileset_Dest = tileset address
    ; d = Number of strings
    ld a, [hl+]
    ld e, a
    ld a, [hl+]
    ld d, a
    Set16 wMenu_MainMenu_StringToTileset_Dest, de
    Get8 d, hl+

    ; Copy every string sequentially into the tileset
    ; Struct: dw StringPointer; db StringLength
    .Loop:
        push de
        ld a, [hl+]
        ld c, a
        ld a, [hl+]
        ld b, a
        Set16 wMenu_MainMenu_StringToTileset_Source, bc
        Mov8 wMenu_MainMenu_StringToTileset_Length, hl+
        push hl
        call Menu_MainMenu_StringToTileset
        pop hl
        pop de
        dec d
        jr nz, .Loop

    ; The code for the rest of this function is very complicated
    ; It would have been better to have just made a function handler jump table for each menu id
    ; Oh well!

    ; Special handling of the individual menu options
    ; Menu_MainMenu_ID_MAIN, Menu_MainMenu_ID_CLEAR, Menu_MainMenu_ID_UNUSED and Menu_MainMenu_ID_DEBUG
    ; are checked first because they don't load any new tilemaps
    ; (i.e. the pointer is null in Menu_MainMenu_TopTilemapTable)
    .CheckMAIN_CLEAR_UNUSED:
    ld a, [wMenu_MainMenu_CurrentMenu]
    cp Menu_MainMenu_ID_SPELL
    jr nc, .CheckDEBUG ;Jump if index >= Menu_MainMenu_ID_SPELL
        .Index_MAIN_CLEAR_UNUSED:
            ; Some really weird hacky way of transforming the selected menu id
            ; The programmer came up with this brilliant way to do these 3 transformations
            ; But then the menu options changed, but in order to not cause any bugs, they didn't
            ; want to change this and so here the code remains.
            ; Menu_MainMenu_ID_MAIN -> Menu_MainMenu_ID_CLEAR
            ; Menu_MainMenu_ID_CLEAR -> Menu_MainMenu_ID_TONY_
            ; Menu_MainMenu_ID_UNUSED -> Menu_MainMenu_ID_RINGS (unused transformation)
            ; Update the selected menu id and then rerun Menu_MainMenu_DrawCurrentTop
            inc a
            cp Menu_MainMenu_ID_MAIN + 1
            jr z, .Skip
                sla a
                inc a
            .Skip:
            ld [wMenu_MainMenu_CurrentMenu], a
            jr Menu_MainMenu_DrawCurrentTop

    .CheckDEBUG:
    ld a, [wMenu_MainMenu_CurrentMenu]
    cp Menu_MainMenu_ID_DEBUG
        .Index_DEBUG:
            ; Don't do anything special
            jp z, .Done

    ; All the other menus actually load a real tilemap at the top - do this now
    call Menu_MainMenu_LoadTopTilemap

    .CheckRINGS:
    ld a, [wMenu_MainMenu_CurrentMenu]
    cp Menu_MainMenu_ID_RINGS
    jr nz, .CheckITEMS
        .Index_RINGS:
            call Menu_MainMenu_Setup_Rings
            jp .Done
    .CheckITEMS:
    cp Menu_MainMenu_ID_ITEMS
    jr nz, .CheckSPELL
        .Index_ITEMS:
            ; Load the entries
            ld bc, xInventory_Items
            FSet16 wMenu_MainMenu_Entry_QuantityTable, bc
            ld bc, Item_Table
            FSet16 wMenu_MainMenu_Entry_EntryDataTable, bc
            Set8 wMenu_MainMenu_Entry_TopChoiceCursorID, Enum_Menu_CursorTable_MainMenu_Entry_0
            Set8 wMenu_MainMenu_Entry_DatatableWidth, ItemSpell_ROWSIZE
            call Menu_MainMenu_BuildEntries
            call Menu_MainMenu_SetupEntryQuantities
            ; Move the cursor and load the new cursor data
            Set8 wMenu_CursorID, Enum_Menu_CursorTable_MainMenu_Entry_0
            Do_CallForeign Menu_LoadCursorRowData
            jp .Done

    .CheckSPELL:
    cp Menu_MainMenu_ID_SPELL
    jr nz, .CheckRELIC
        .Index_SPELL:
            ; Load the entries
            ld bc, xInventory_Spells
            FSet16 wMenu_MainMenu_Entry_QuantityTable, bc
            ld bc, Spell_Table
            FSet16 wMenu_MainMenu_Entry_EntryDataTable, bc
            Set8 wMenu_MainMenu_Entry_TopChoiceCursorID, Enum_Menu_CursorTable_MainMenu_Spell_0
            Set8 wMenu_MainMenu_Entry_DatatableWidth, ItemSpell_ROWSIZE
            call Menu_MainMenu_BuildEntries
            call Menu_MainMenu_SetupEntryQuantities
            ; Move the cursor and load the new cursor data
            Set8 wMenu_CursorID, Enum_Menu_CursorTable_MainMenu_Spell_0
            Do_CallForeign Menu_LoadCursorRowData
            jp .Done

    .CheckRELIC:
    cp Menu_MainMenu_ID_RELIC
    jr nz, .CheckINFUSED
        .Index_RELIC:
            ; Initialize some relic variables
            xor a
            ld [wMenu_MainMenu_EquippingRelic], a
            ld [wMenu_MainMenu_RemovedRelicID], a
            ; Load the entries
            ld bc, xInventory_Relics
            FSet16 wMenu_MainMenu_Entry_QuantityTable, bc
            ld bc, Relic_Table
            FSet16 wMenu_MainMenu_Entry_EntryDataTable, bc
            Set8 wMenu_MainMenu_Entry_TopChoiceCursorID, Enum_Menu_CursorTable_MainMenu_Entry_0
            Set8 wMenu_MainMenu_Entry_DatatableWidth, Relic_ROWSIZE
            call Menu_MainMenu_BuildEntries
            call Menu_MainMenu_SetupEntryQuantities
            ; Move the cursor and load the new cursor data
            Set8 wMenu_CursorID, Enum_Menu_CursorTable_MainMenu_Entry_0
            Do_CallForeign Menu_LoadCursorRowData
            jr .Done

    .CheckINFUSED:
    cp Menu_MainMenu_ID_INFUSED
    jr nz, .CheckTONY_
        .Index_INFUSED:
            ; Load the entries
            ld bc, xInventory_Infused
            FSet16 wMenu_MainMenu_Entry_QuantityTable, bc
            Set8 wMenu_MainMenu_Entry_TopChoiceCursorID, Enum_Menu_CursorTable_MainMenu_Entry_0
            Set8 wMenu_MainMenu_Entry_DatatableWidth, $01 ; There is no real infused data table. This line is unused and can be removed
            call Menu_MainMenu_BuildEntries
            call Menu_MainMenu_SetupEntryQuantities

            ; Loop through the 5 entries, and remove the üåüNAME if the name is blank, since the üåü was pre-set by the tilemap
            ; We do this by checking if each entry is a valid option, which was determined by Menu_MainMenu_SetupEntryQuantities
            ld hl, wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Entry_0
            ld d, $00
            .RemoveLoop:
                ; Check if the cursor id of the corresponding entry is valid
                ld a, [hl+]
                and a
                jr nz, .Continue
                .RemoveInfused:
                    ; Valid! Remove the üåüCREATURENAME
                    ; Calculate the tilemap position. Y = 3 + 1*loopcount
                    push hl
                    push de
                    ld b, d
                    ld c, (WINDOW_COORD_04_06 - WINDOW_COORD_03_06)
                    call Math_Mult
                    ld bc, WINDOW_COORD_03_06
                    add hl, bc
                    ; Erase the line of text
                    ld c, (1 + CreatureName_SIZE) ; +1 for the üåü icon
                    ld a, Textbox_TILEID_BLANK
                    .TileLoop:
                        ld [hl+], a
                        dec c
                        jr nz, .TileLoop
                    pop de
                    pop hl
                .Continue:
                    ; Loop 5 times
                    inc d
                    ld a, $05
                    cp d
                    jr nz, .RemoveLoop
            ; Move the cursor and load the new cursor data
            Set8 wMenu_CursorID, Enum_Menu_CursorTable_MainMenu_Entry_0
            Do_CallForeign Menu_LoadCursorRowData
            jr .Done
    .CheckTONY_:
    cp Menu_MainMenu_ID_TONY_
    jr nz, .CheckABILITY
        .Index_TONY_:
            call Menu_MainMenu_Setup_Tony_
            jr .Done
    .CheckABILITY:
    cp Menu_MainMenu_ID_ABILITY
    jr nz, .CheckGLYPH
        .Index_ABILITY:
            call Menu_MainMenu_Setup_Ability
            jr .Done
    .CheckGLYPH:
    cp Menu_MainMenu_ID_GLYPH
    jr nz, .CheckGLYPH     ;Infinite loop if invalid entry. This should never happen. Modify this if you add a new menu option
        .Index_GLYPH:
            call Menu_MainMenu_Setup_Glyph
            ;jr .Done

    .Done:
    ; Screen is updated, so no need to update anymore
    xor a
    ld [wMenu_MainMenu_NeedsScreenUpdate], a
    ret

    ; $636A
Menu_MainMenu_SetupEntryQuantities:
    ; Loads the quantities of the items and writes them to the tilemap
    ; Will write "   " if the quantity is 0
    ; If the quantity is 0, it will also disable the cursor from moving over this choice
    ;
    ; Arguments:
    ;   [wMenu_MainMenu_Entry_EntriesPointers] list of 5 quantitites
    ;   [wMenu_MainMenu_Entry_TopChoiceCursorID] - offset for the Cursor ID of the 5 entries
    ; Output:
    ;   wMenu_MainMenu_CursorTableValidIDs+wMenu_MainMenu_Entry_TopChoiceCursorID -> 5 bytes. 1 if non-zero, 0 if zero
    Battery_On
    Battery_SetBank "XRAM Gamestate"
    xor a
    ld [rVBK], a
    ; Loop through the 5 entries
    ; c = range(5)
    ld bc, $0000 ; inefficiency - could just set c = 0
    .Loop:
        ; Get the current entry
        ld hl, wMenu_MainMenu_Entry_EntriesPointers.Entry0
        ld b, $00
        add hl, bc
        add hl, bc

        ; Get the current entry's quantity
        DerefHL
        xor a
        cp [hl]
        jr nz, .NonZeroQuantity
        .ZeroQuantity:
            ; Zero quantity. Erase any potential number and write "   " instead
            ld a, (Textbox_TILEID_BLANK - Menu_MainMenu_TILEID_NUMBERS) ;We want to use Textbox_TILEID_BLANK. But later in the code the tiles are shifted by Menu_MainMenu_TILEID_NUMBERS, subtract by this
            ld hl, wX1
            ld [hl+], a
            ld [hl+], a
            ld [hl+], a

            ; Locate the cursor table id of EntryX
            Get8 e, wMenu_MainMenu_Entry_TopChoiceCursorID
            ld d, $00
            push hl
            ld hl, wMenu_MainMenu_CursorTableValidIDs
            add hl, bc
            add hl, de
            ; Set it to 0. This is an invalid option
            xor a
            ld [hl], a
            pop hl
            jr .Continue
        .NonZeroQuantity:
            ; Non-zero quantity.

            ; Let's make the cursor table id of EntryX a valid selection
            Get8 e, wMenu_MainMenu_Entry_TopChoiceCursorID
            ld d, $00
            push hl
            ld hl, wMenu_MainMenu_CursorTableValidIDs
            add hl, bc
            add hl, de
            Set8 hl, $01
            pop hl

            ; Convert the number into digits
            ld e, [hl]
            ld d, $00
            push bc
            call Math_ConvertNumberToDigits
            pop bc
            ;.jr Continue
        .Continue:
        ; Y = 3 + loopcount
        ld b, (WINDOW_COORD_04_01 - WINDOW_COORD_03_01)
        call Math_Mult
        ld de, WINDOW_COORD_03_01
        add hl, de
        ; Update the tilemap
        ld d, Menu_MainMenu_TILEID_NUMBERS
        call Menu_MainMenu_SetTilemap3DigitNumber
        ; Loop a total of 5 times
        inc c
        ld a, $05
        cp c
        jr nz, .Loop
    Battery_Off
    ret

    ; $63D6
Menu_MainMenu_BuildEntries::
    ; Loads the names of the item/infused/relics
    ; 
    ; 1) It determines which 5 items to display
    ; 2) It checks to see if any entries exist before the 1st item. If so, it will disable the arrow up option
    ; 2) It checks to see if any entries exist past the 5th item. If so, it will disable the arrow down option
    ; 3) Quits if 0 entries were found
    ; 3) It copies the strings of the 5 entries into the tilemap

    ; Find the 5 entries to display
    Battery_On
    Battery_SetBank "XRAM Gamestate"
    call Menu_MainMenu_Get5Entries

    ; By default we will enable the arrows, and then check to see if we must disable them
    ld a, $01
    ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Spell_Up], a
    ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Spell_Dn], a
    ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Entry_Up], a
    ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Entry_Dn], a

    .CheckArrowUp:
    ; If there is at least 1 valid entry before the top entry, then we can enable the up arrow.

    ; first entry index = [wMenu_MainMenu_Entry_EntriesPointers.Entry0] - [wMenu_MainMenu_Entry_QuantityTable]
    FGet16 bc, wMenu_MainMenu_Entry_QuantityTable
    TwosComp bc
    FGet16 hl, wMenu_MainMenu_Entry_EntriesPointers.Entry0
    add hl, bc
    ld b, $00
    ld c, l

    .UpLoop:
        ; Loop through all the previous entries. If we find a single one that has a non-zero quantity, we keep the up arrow
        FGet16 hl, wMenu_MainMenu_Entry_QuantityTable
        dec bc
        ld a, -1       ;We reached index -1 so there are no valid previous entries
        cp c
        jr z, .NoValidPreviousEntry
        add hl, bc
        ld a, [hl]
        and a
        jr z, .UpLoop
        .ValidPreviousEntry:
            ;One of the previous entries is non-zero, so we keep ArrowUp
            jr .CheckArrowDown
        .NoValidPreviousEntry:
            ; Disable the up arrow option and hide the arrow
            xor a
            ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Spell_Up], a
            ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Entry_Up], a
            ld a, Textbox_TILEID_BLANK
            ld hl, WINDOW_COORD_01_09
            ld [hl+], a
            ld [hl+], a
            ; jr .CheckArrowDown

    .CheckArrowDown:
    ; Do the same thing but this time checking for valid entries after the last visible entry

    ; last entry index = [wMenu_MainMenu_Entry_EntriesPointers.Entry4] - [wMenu_MainMenu_Entry_QuantityTable]
    FGet16 bc, wMenu_MainMenu_Entry_QuantityTable
    TwosComp bc
    FGet16 hl, wMenu_MainMenu_Entry_EntriesPointers.Entry4
    add hl, bc
    ld b, $00
    ld c, l

    ; If the index of the 5th entry is 0, meaning <5 items are displayed, disable ArrowDown
    ld a, c
    and c        
    jr z, .NoValidNextEntry
    .DownLoop:
        ; Loop through all the subsequent entries. If we find a single one that has a non-zero quantity, we keep the down arrow
        FGet16 hl, wMenu_MainMenu_Entry_QuantityTable
        inc bc
        ld a, $FF ;We reached index 255 so we confirm we can disable ArrowDown
        cp c
        jr z, .NoValidNextEntry
        add hl, bc
        ld a, [hl]
        and a
        jr z, .DownLoop
        .ValidNextEntry:
            ;One of the later entries is non-zero, so we keep ArrowDown
            jr .FinishedArrowChecks
        .NoValidNextEntry:
            ; Disable the down arrow option and hide the arrow
            xor a
            ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Spell_Dn], a
            ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Entry_Dn], a
            ld a, Textbox_TILEID_BLANK
            ld hl, WINDOW_COORD_09_09
            ld [hl+], a
            ld [hl+], a
    .FinishedArrowChecks:
    Battery_Off

    ; Quit if no items were found
    ld a, [wMenu_MainMenu_Entry_EntriesUpdated]
    and a
    ret z
    Battery_Off ; bug - this appears twice

    ; Loop 5 times to write the 5 entries to the tilesets
    ; c = range($0A, step=2)
    ld bc, $0000 ; inefficient - could have just set c to $00
    .DoEntryLoop:
        ; Get the current entry pointer
        ld b, $00
        ld hl, wMenu_MainMenu_Entry_EntriesPointers
        add hl, bc
        DerefHL
        push bc

        ; entry index = c = [wMenu_MainMenu_Entry_EntriesPointers.EntryX] - [wMenu_MainMenu_Entry_QuantityTable]
        Get16 bc, wMenu_MainMenu_Entry_QuantityTable
        TwosComp bc
        add hl, bc
        ld c, l

        ; Get the entry name
        Get8 b, wMenu_MainMenu_Entry_DatatableWidth
        ld a, [wMenu_MainMenu_CurrentMenu]
        cp Menu_MainMenu_ID_INFUSED
        jr z, .DoInfused
        .DoRelicOrItemSpell:
            ; For relics and items, get the address of the desired row of data
            ; pointer = wMenu_MainMenu_Entry_EntryDataTable + index*wMenu_MainMenu_Entry_DatatableWidth
            call Math_Mult
            Get16 bc, wMenu_MainMenu_Entry_EntryDataTable
            add hl, bc

            ; Prepare to copy the data into memory
            Set16 wBattle_CopyBuffer_Source, hl
            ld bc, wMenu_Battle_TableRowBuffer
            FSet16 wBattle_CopyBuffer_Destination, bc

            ; Now it depends if it is relics or an item
            ld a, [wMenu_MainMenu_CurrentMenu]
            cp Menu_MainMenu_ID_RELIC
            jr z, .DoRelic
            .DoItemSpell:
                ; Copy the data into buffer
                Do_CallForeign ItemSpell_GetDataFromAddress
                jr .CopyBufferDone
        .DoInfused:
            ; Copy the creature's name to the buffer
            Set8 wBattle_CopyBuffer_ListIndex, c
            ld bc, wMenu_Battle_TableRowBuffer
            FSet16 wBattle_CopyBuffer_Destination, bc
            Do_CallForeign CreatureName_CopyToDest
            jr .CopyBufferDone

        .DoRelic:
            ; Copy the data into buffer
            Do_CallForeign Relic_GetDataFromAddress
            ; jr .CopyBufferDone
        .CopyBufferDone:

        ; Dest: Calculate the destination position in tileset of the string
        ; Menu_MainMenu_VRAM_ENTRY_0 + index*(Menu_MainMenu_VRAM_ENTRY_1 - Menu_MainMenu_VRAM_ENTRY_0)
        pop bc
        push bc
        srl c   ;c/2 is the index of the displayed entry (0-4)
        ld b, (Menu_MainMenu_VRAM_ENTRY_1 - Menu_MainMenu_VRAM_ENTRY_0)
        call Math_Mult
        ld bc, Menu_MainMenu_VRAM_ENTRY_0
        add hl, bc

        ; Source: Depending on the type of copied data, the location of the name of the entry varies
        ld a, [wMenu_MainMenu_CurrentMenu]
        .CheckRelic:
        cp Menu_MainMenu_ID_RELIC
        jr nz, .CheckInfused
            .IsRelic:
                ld bc, wMenu_Battle_TableRowBuffer.Relic_Name
                jr .SourceFound
        .CheckInfused:
        cp Menu_MainMenu_ID_INFUSED
        jr z, .IsInfused
            .IsItemSpell:
                ; By exclusion of other choices
                ld bc, wMenu_Battle_TableRowBuffer.ItemSpell_Name
                jr .SourceFound
            .IsInfused:
                ld bc, wMenu_Battle_TableRowBuffer
                ;Copy the string to the tileset
        .SourceFound:

        ; Copy the string
        ASSERT ItemSpell_NAMESIZE >= CreatureName_SIZE
        ASSERT ItemSpell_NAMESIZE >= Relic_NAMESIZE
        Set8 wMenu_MainMenu_StringToTileset_Length, ItemSpell_NAMESIZE ;max(CreatureName_SIZE, Relic_NAMESIZE, ItemSpell_NAMESIZE)
        Set16 wMenu_MainMenu_StringToTileset_Dest, hl
        FSet16 wMenu_MainMenu_StringToTileset_Source, bc
        call Menu_MainMenu_StringToTileset

        ; Increment and loop if we are not at the end
        pop bc
        inc bc
        inc bc
        ld a, c
        cp (wMenu_MainMenu_Entry_EntriesPointers.End - wMenu_MainMenu_Entry_EntriesPointers)
        jp nz, .DoEntryLoop
    ret

    ; $6530
Menu_MainMenu_EquipRelic::
    ; Equips the relic in wMenu_MainMenu_EquippingRelic
    ; Adjust's Tony's inventory to take away the new relic and give back
    ; the relic that the ring previously had equipped, if it isn't null
    ;
    ; Inputs:
    ;   wMenu_MainMenu_EquippingRelic - the relic to equip
    ;   wMenu_MainMenu_CurRingRelicSlot the slot to which to apply the relic
    ;   wMenu_MainMenu_CurRing - the current ring
    ; Outputs:
    ;   wMenu_MainMenu_CurrentMenu set to Menu_MainMenu_ID_RINGS
    ;   wMenu_CursorID set to Enum_Menu_CursorTable_MainMenu_Rings_R0 or R1
    ;   wMenu_MainMenu_NeedsScreenUpdate set to Enum_Menu_MainMenu_SCREENUPDATE_YES

    ; We go to the Rings menu next
    Set8 wMenu_MainMenu_CurrentMenu, Menu_MainMenu_ID_RINGS
    Set8 wMenu_MainMenu_NeedsScreenUpdate, Enum_Menu_MainMenu_SCREENUPDATE_YES
    ld a, [wMenu_MainMenu_CurRingRelicSlot]
    add Enum_Menu_CursorTable_MainMenu_Rings_R0 ; The cursor should be on relic 0 or relic 1, depending on which one we had selected
    ld [wMenu_CursorID], a

    ; Get the ring's creature's struct's relic0 or relic1
    Battery_SetBank "XRAM Gamestate"
    Battery_On
    Get8 c, wMenu_MainMenu_CurRing
    ld b, $00
    ld hl, xInventory_Rings
    add hl, bc
    ld a, [hl]
    ld c, a
    ld b, Creature_SIZE
    call Math_Mult
    ld bc, xCreature_00_Hero.Relic0
    add hl, bc
    Get8 c, wMenu_MainMenu_CurRingRelicSlot
    ld b, $00
    add hl, bc

    ; Swap the currently equipped relic with the new relic
    Battery_SetBank "XRAM Creatures"
    ld a, [wMenu_MainMenu_EquippingRelic]
    ld b, [hl]
    ld [hl], a

    ; Check if the removed relic was Relic_NULL or not
    Battery_SetBank "XRAM Gamestate"
    ld a, b
    and a
    jr z, .Continue
    .NotNull
        ; If not null, give the removed relic back into the inventory
        ld c, a
        ld b, $00
        ld hl, xInventory_Relics
        add hl, bc
        inc [hl]

    .Continue:
    ; Take away the new relic from Tony
    Get8 c, wMenu_MainMenu_EquippingRelic
    ld b, $00
    ld hl, xInventory_Relics
    add hl, bc
    dec [hl]
    Battery_Off
    ret

    ; $659C
Menu_MainMenu_Setup_Glyph:
    ; Copies the glyph tileset into memory
    ; Then modifies the tilemap showing the completed the core stones based on progression
    ; Arguments:
    ;   xGlyphState (assumed to be $01-$05)

    ; Load the tileset
    call Menu_MainMenu_LoadGlyph

    ; Get xGlyphState
    xor a
    ld [rVBK], a
    Battery_SetBank "XRAM Gamestate"
    Battery_On
    Get8 d, xGlyphState
    Battery_Off

    ; The glyph is loaded by default as empty! We need to modify the tilemap to add the core stones as needed

    ; If no Core stones, end
    ld a, d
    cp $01
    ret z

    ; Add the first Core stone
    ld hl, WINDOW_COORD_06_09
    ld bc, TILEMAP_GlyphCoreStone1
    LdHLIBCI
    LdHLIBCI
    ld a, d  ; inefficiency - we don't need to repeatedly get the value from d
    cp $02
    ret z

    ; Add the second Core stone
    ld hl, WINDOW_COORD_07_09
    ld bc, TILEMAP_GlyphCoreStone2
    LdHLIBCI
    ld a, d
    cp $03
    ret z

    ; Add the third Core stone
    ld hl, WINDOW_COORD_07_0A
    ld bc, TILEMAP_GlyphCoreStone3
    LdHLIBCI
    ld a, d
    cp $04
    ret z

    ; Add the fourth Core stone
    ld hl, WINDOW_COORD_08_09
    ld bc, TILEMAP_GlyphCoreStone4
    LdHLIBCI
    LdHLIBCI
    ld a, d
    cp $05
    ret z

    ; Add the fifth Core stone
    ld bc, TILEMAP_GlyphCoreStone5
    call Menu_MainMenu_GlyphCoreStone5
    ret

    ; $65FD
Menu_MainMenu_GlyphCoreStone5::
    ; Copies the tilemap or attrmap of glyph stone 5 located into VRAM
    ; Inputs:
    ;   bc: source address (tilemap or attrmap)
    ;   VRAM bank preselected
    ld hl, WINDOW_COORD_01_08
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    ld hl, WINDOW_COORD_02_08
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    ld hl, WINDOW_COORD_03_08
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    ld hl, WINDOW_COORD_04_08
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    ld hl, WINDOW_COORD_05_08
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    LdHLIBCI
    ret

    ; $6649
Menu_MainMenu_Setup_Tony_::
    ; Loads the hero's portrait
    ; Loads the hero's Level and Experience
    ; Loads the hero's 5 abilities and then erases the ones not obtained
    ; Arguments:
    ;   xHeroAbilities - 0-5
    ;   xCreature_00_Hero.Level
    ;   xCreature_00_Hero.Experience

    ; Load the PortraitAddressBank of BITMAP_Icon_Tony (lower 4 bits specify the bank (bank 8), upper 12 bits are the address)
    ; So that e = bank, and hl = address
    ; This is kind of inefficient. It would have been simpler to use code such as
    ; Set16 wVBlank_SourceAddress, BITMAP_Icon_Tony
    ; ld e, BANK(BITMAP_Icon_Tony)
    db $21 ;ld hl,
        PortraitAddressBank BITMAP_Icon_Tony
    ld a, l     
    and $0F
    ld e, a ; e = bank
    ld a, l
    and $F0
    ld l, a ; hl = address
    Set16 wVBlank_SourceAddress, hl
    ld bc, Menu_MainMenu_VRAM_TONY_ICON
    FSet16 wVBlank_DestAddress, bc
    Set8 wVBlank_DestVBK, $01

    ; Copy the icon into VRAM
    ld d, 25
    .CopyLoop:
        ld hl, Interrupt_VBlankFunc_CopyTile
        call CallForeign
        dec d
        jr nz, .CopyLoop

    ; Load Tony's level into the tilemap
    Battery_SetBank "XRAM Creatures"
    Battery_On
    Get8 e, xCreature_00_Hero.Level
    ld d, $00
    Battery_Off
    call Math_ConvertNumberToDigits
    xor a
    ld [rVBK], a
    ld a, [wX10]
    add Menu_MainMenu_TILEID_NUMBERS
    ld [WINDOW_COORD_02_0B], a
    ld a, [wX1]
    add Menu_MainMenu_TILEID_NUMBERS
    ld [WINDOW_COORD_02_0C], a

    ; Load Tony's experience into the tilemap
    Battery_SetBank "XRAM Creatures"
    Battery_On
    FGet16_BigEndian de, xCreature_00_Hero.Experience
    Battery_Off
    call Math_ConvertNumberToDigits
    ld hl, WINDOW_COORD_03_0B
    ld d, Menu_MainMenu_TILEID_NUMBERS
    call Menu_MainMenu_SetTilemap3DigitNumber

    ; Load Tony's abilities
    call Menu_MainMenu_LoadAbilities
    ;Load the Level and Exprnce icons
    call Menu_MainMenu_LoadStatsHeaders.Tony

    ; Erase the abilities that Tony has not yet unlocked
    xor a
    ld [rVBK], a
    Battery_SetBank "XRAM Gamestate"
    Battery_On
    Mov8 wMenu_MainMenu_TempIndex, xHeroAbilities
    Battery_Off
    .CheckEnergyBand:
        xor a
        ld hl, wMenu_MainMenu_TempIndex
        or [hl]
        jr z, .EraseEnergyBand
        .KeepEnergyBand:
            dec [hl]
            jr .CheckCrystalGloves
        .EraseEnergyBand:
            ld hl, WINDOW_COORD_07_01
            call Menu_MainMenu_EraseTonyAbility
            jr .EraseCrystalGloves
    .CheckCrystalGloves:
        xor a
        ld hl, wMenu_MainMenu_TempIndex
        or [hl]
        jr z, .EraseCrystalGloves
        .KeepCrystalGloves
            dec [hl]
            jr .CheckAgadonsBoots
        .EraseCrystalGloves:
            ld hl, WINDOW_COORD_07_06
            call Menu_MainMenu_EraseTonyAbility
            jr .EraseAgadonsBoots
    .CheckAgadonsBoots:
        xor a
        ld hl, wMenu_MainMenu_TempIndex
        or [hl]
        jr z, .EraseAgadonsBoots
        .KeepAgadonsBoots
            dec [hl]
            jr .CheckOrotheanBelt
        .EraseAgadonsBoots:
            ld hl, WINDOW_COORD_07_0B
            call Menu_MainMenu_EraseTonyAbility
            jr .EraseOrotheanBelt
    .CheckOrotheanBelt:
        xor a
        ld hl, wMenu_MainMenu_TempIndex
        or [hl]
        jr z, .EraseOrotheanBelt
        .KeepOrotheanBelt:
            dec [hl]
            jr .CheckEyeOfTheStorm
        .EraseOrotheanBelt:
            ld hl, WINDOW_COORD_07_10
            call Menu_MainMenu_EraseTonyAbility
            jr .EraseEyeOfTheStorm
    .CheckEyeOfTheStorm:
        xor a
        ld hl, wMenu_MainMenu_TempIndex
        or [hl]
        .KeepEyeOfTheStorm:
            ret nz
        .EraseEyeOfTheStorm:
            ld hl, WINDOW_COORD_01_10
            call Menu_MainMenu_EraseTonyAbility
            ret

    ; $673B
Menu_MainMenu_MasterLoop:
    ; Main loop while in the menu
    ; Redraw the screen if needed
    ; Update the cursor
    ; Hijack the <- and -> button presses when hovering over a ring's relic, and make it press "Select" instead to trigger wMenu_SelectFunc

    ; Update the cursor sprite
    call Frame_Ready

    ; If the screen needs to be redrawn, redraw the top half of the screen
    ld a, [wMenu_MainMenu_NeedsScreenUpdate]
    cp Enum_Menu_MainMenu_SCREENUPDATE_YES
    jr nz, .SkipRedraw
    .RedrawScreen:
        call ScreenHide
        call Menu_MainMenu_DrawCurrentTop
        call Menu_MainMenu_DrawAttrmapTop
        call ScreenShow
    .SkipRedraw:

    ; Prepare the cursor for the next frame
    Do_CallForeign Menu_DrawCursorSprite

    ; Hijack the <- and -> button press if it's pressed when hovering over a ring's relic
    ; and replace the button press with "Select"
    ; This will allow the <- and -> buttons to trigger wMenu_SelectFunc as well
    ; Which allows the player to swap relics quickly

    ; Is button left or right?
    ld a, [wCntDown]
    bit button_BIT_RIGHT, a
    jr nz, .ButtonLeftOrRight
    bit button_BIT_LEFT, a
    jr z, .EndHijack
    .ButtonLeftOrRight:
        ; Is the wMenu_CursorID over one of the ring's relics?
        ld a, [wMenu_CursorID]
        cp Enum_Menu_CursorTable_MainMenu_Rings_R0
        jr c, .EndHijack
        cp Enum_Menu_CursorTable_MainMenu_Rings_R1 + 1
        jr nc, .EndHijack
        .OverRingRelic:
            ; Yes, the button press is left or right, AND the cursor is over one of a ring's two relics
            ; Change the button press to instead be the Select button
            xor a
            set button_BIT_SELECT, a
            ld [wCntDown], a
    .EndHijack:

    ; Process the button presses' effect on the cursor/menu
    Do_CallForeign Menu_ButtonCheck

    call System_UpdateGameNoScript
    jp Menu_MainMenu_MasterLoop

    ; $6783
Menu_MainMenu_Open::
    ; The function that is called, when the Start button is pressed to open the main menu

    ; Abort if the textbox is not closed
    ld a, [wTextbox_Position]
    cp Textbox_CLOSED
    ret nz

    ; TODO
    ld a, [hAI_HeroFlags_Current]
    bit 1, a
    ret z

    ; TODO
    ld a, [$C716]
    and a
    ret nz

    ; Abort if the screen is currently fading or unavailable
    ld a, [wMenu_MainMenu_Disabled]
    and a
    ret nz

    ; Lower the volume
    Sound_Request_SetVolume $06

    ; Erase all sprites and hide the screen
    Frame_Init
    call ScreenHide

    ; Store 00:9000-00:9800 and 01:8E00-01:9800 into buffers so we can use the space
    call Menu_MainMenu_BackupVRAMObjectsChars
    Do_CallForeign Cardscene_BackupBackgroundCharsBC

    ; Set Window to 0,0
    xor a
    ld [rWY], a
    Set8 rWX, $07

    ; Initialize the tiles reserved for the upper menu with a debug string to
    ; help the developer with bugs or making new tilemaps
    ; This function could be safely removed
    call Menu_MainMenu_VRAMDebugInitialize

    ; The menu will first open as Menu_MainMenu_ID_MAIN
    Set8 wMenu_MainMenu_CurrentMenu, Menu_MainMenu_ID_MAIN

    ; Unused: The next two lines are not useful, as the variable gets overwritten soon after this
    ; This was probably a remnant of the old code used to load the data that is now in STRINGSET_Menu_MainMenu_Main
    ld bc, $8860
    FSet16 wMenu_MainMenu_StringToTileset_Dest, bc

    ; Use the MainMenu CursorTable
    ld bc, Menu_CursorTable_MainMenu
    FSet16 wMenu_CursorTable, bc

    xor a
    ld [wMenuChoice_BlinkFingerTimer], a ; Reset the blinking counter
    ld [wMenuChoice_ConfirmingChoice], a ; Not double-clicking
    ld [wMenu_MainMenu_CurRing], a ; Initial ring is ring 0
    ld [wMenu_MainMenu_RemovedRelicID], a ; The relic that the user has picked up from a DC (null)

    ; Set the cursor to Tony
    ld [wMenu_CursorID], a ; = Enum_Menu_CursorTable_MainMenu_Tony
    Do_CallForeign Menu_LoadCursorRowData
    
    Set8 wMenu_KeyMask, %11111111  ;all buttons valid - in the alpha version, the select button was disabled
    Set8 wMenuChoice_FingerTile, Textbox_TILEID_CURSORHOVER ; The cursor is hovering right now
    Set8 wMenu_BlinkFlag, Menu_CURSOR_BLINK ; The cursor should blink
    Set8 wVBlank_DestVBK, $01 ; The main menu is entirely in VBK 1

    ;Copy fat arrow to VRAM tile $7F
    ld bc, BITMAP_Font_FatArrow
    FSet16 wVBlank_SourceAddress, bc
    ld bc, Menu_MainMenu_VRAM_FATARROW
    FSet16 wVBlank_DestAddress, bc 
    ld e, BANK(BITMAP_Font)
    ld hl, Interrupt_VBlankFunc_CopyTile
    call CallForeign

    ; Copy üåüList to VRAM (tile $7A - $7E)
    ld bc, sMenu_MainMenu_InfusedList
    FSet16 wMenu_MainMenu_StringToTileset_Source, bc
    ld bc, Menu_MainMenu_VRAM_INFUSEDLIST
    FSet16 wMenu_MainMenu_StringToTileset_Dest, bc
    Set8 wMenu_MainMenu_StringToTileset_Length, (sMenu_MainMenu_InfusedList.End - sMenu_MainMenu_InfusedList)
    call Menu_MainMenu_StringToTileset

    ; Copy colon : to VRAM tile $75
    ld bc, BITMAP_Font_Colon
    FSet16 wVBlank_SourceAddress, bc
    ld bc, Menu_MainMenu_VRAM_COLON
    FSet16 wVBlank_DestAddress, bc
    ld e, BANK(BITMAP_Font)
    ld hl, Interrupt_VBlankFunc_CopyTile
    call CallForeign

    ; Write "Save" if in Overworld, otherwise write "    " (blank) (tiles 76-79)
    ld bc, sMenu_MainMenu_SaveBlank
    ld a, [wMenu_MainMenu_IsInOverworld]
    and a
    jr z, .SkipHeroInOverworld   ;Save does not show up
    .HeroInOverworld:
        ld bc, sMenu_MainMenu_Save   ;Save shows up
    .SkipHeroInOverworld:
    FSet16 wMenu_MainMenu_StringToTileset_Source, bc
    ld bc, Menu_MainMenu_VRAM_SAVE
    FSet16 wMenu_MainMenu_StringToTileset_Dest, bc
    Set8 wMenu_MainMenu_StringToTileset_Length, (sMenu_MainMenu_Save.End - sMenu_MainMenu_Save)
    call Menu_MainMenu_StringToTileset

    ; Set the Start and Select button handlers
    ; Start -> Go back to overworld
    ; Select -> Try to swap relics
    ld bc, MenuFunc_StartButtonMainMenuHandler
    FSet16 wMenu_StartFunc, bc
    ld bc, MenuFunc_SelectButtonMainMenuHandler
    FSet16 wMenu_SelectFunc, bc

    ; Initialize wMenu_MainMenu_CursorTableValidIDs to all $01
    ld hl, wMenu_MainMenu_CursorTableValidIDs
    Set16 wMenu_CursorTableValidIDsPointer, hl
    ld a, $01
    ld d, (wMenu_MainMenu_CursorTableValidIDs.End - wMenu_MainMenu_CursorTableValidIDs) + 1 ; bug - see the definition in wMenu_MainMenu_CursorTableValidIDs - remove the +1 if the bug is fixed
    .SetupTableLoop:
        ld [hl+], a
        dec d
        jr nz, .SetupTableLoop

    Battery_SetBank "XRAM Gamestate"
    Battery_On

    ; If there are no Spells, disable the spell option
    .FindAtLeastOneSpell:
    ld hl, xInventory_Spells+1 ; The 0th spell is a special null spell
    ld d, (xInventory_Spells.End - (xInventory_Spells+1) - 1)
    xor a
    .CheckSpellLoop:
        or [hl]
        inc hl
        dec d
        jr nz, .CheckSpellLoop
    and a
    jr nz, .FindAtLeastOneItem
    .SpellNotFound:
        ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Spell], a ; Set to 0

    ; If there are no Items, disable the item option
    .FindAtLeastOneItem:
    ld hl, xInventory_Items+1 ; The 0th spell is a special null item
    ld d, (xInventory_Items.End - (xInventory_Items+1) - 1)
    xor a
    .CheckItemLoop:
        or [hl]
        inc hl
        dec d
        jr nz, .CheckItemLoop
    and a
    jr nz, .FindAtLeastOneInfused
    .ItemNotFound
        ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Items], a ; Set to 0

    ; If there are no Infused animite, disable the Infused option
    .FindAtLeastOneInfused:
    ld hl, xInventory_Infused
    ld d, (xInventory_Infused.End - xInventory_Infused - 1)
    xor a
    .CheckInfusedLoop:
        or [hl]
        inc hl
        dec d
        jr nz, .CheckInfusedLoop
    and a
    jr nz, .InfusedFound
    .InfusedNotFound:
        ld [wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_InfuList], a
    .InfusedFound:

    ; If the first ring is $FF, then the hero has no rings
    ; Therefore, disable the Ring option
    ld a, [xInventory_Rings]
    inc a
    ld [wMenu_MainMenu_CursorTableValidIDs+Enum_Menu_CursorTable_MainMenu_Rings], a

    ; Enable the glyph only if the glyph has at least been obtained
    Mov8 wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Glyph, xGlyphState
    ; Enable save in the overworld
    Mov8 wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Save, wMenu_MainMenu_IsInOverworld

    Battery_Off

    ; Draw the tilemap and attrmap for the bottom menu
    call Menu_MainMenu_BottomMenuInit

    ; Draw the top part of the screen
    call Menu_MainMenu_DrawCurrentTop ;Index = Main, so loads all the tilesets for bottom + Tony

    ; Turn on the screen and give control back to the user
    call ScreenShow
    call Frame_Ready
    call System_UpdateGameNoScript
    jp Menu_MainMenu_MasterLoop

    ; $6911
Menu_MainMenu_Get5Entries:
    ; Loads 5 entries to display on the screen
    ; It will check if the user had requested a next or previous page and process that as well
    ; Arguments:
    ;   [wMenu_MainMenu_Entry_QuantityTable] - points to the table of quantities that Tony has
    ; Outputs:
    ;   wMenu_MainMenu_Entry_EntriesUpdated -> 1 by default. 0 if no entries were found
    ;   wMenu_MainMenu_Entry_PageEdge -> Non-zero if the list reached the end (see mainmenu.include.asm for definition)

    ; First, figure out where the cursor is.
    ; Based on this, either reset to the first entry, or do a page down/up
    .CheckFirstPage:
    Set8 wMenu_MainMenu_Entry_EntriesUpdated, $01
    ld a, [wMenu_CursorID]
    cp Enum_Menu_CursorTable_MainMenu_Entry_0 ;Infused, Items, Relic
    jr z, .DoFirstPage
    cp Enum_Menu_CursorTable_MainMenu_Spell_0 ;Spells
    jr z, .DoFirstPage
    jr .CheckGoUp ;Arrow button was pressed
        .DoFirstPage:
            ; There should be no Up arrow if we are starting with the first item
            ; Set the pointers for the 5 items to null to start
            ld hl, wMenu_MainMenu_Entry_EntriesPointers
            Set8 wMenu_MainMenu_Entry_PageEdge, Enum_Menu_PAGEEDGE_TOP
            ld c, (wMenu_MainMenu_Entry_EntriesPointers.End - wMenu_MainMenu_Entry_EntriesPointers)
            xor a
            .LoopNullify:
                ld [hl+], a
                dec c
                jr nz, .LoopNullify
            ; Get the user's quantity table
            ld hl, wMenu_MainMenu_Entry_QuantityTable
            ld a, [hl+]
            ld b, [hl]
            ld c, a
            dec bc ; decrease by 1 because we increase before checking
            ld hl, wMenu_MainMenu_Entry_EntriesPointers
            jr .DownwardsSearch

    .CheckGoUp:
    ld a, [wMenu_CursorID]
    cp Enum_Menu_CursorTable_MainMenu_Entry_Up
    jp z, .DoPressedUp
    cp Enum_Menu_CursorTable_MainMenu_Spell_Up
    jp z, .DoPressedUp
    cp Enum_Menu_CursorTable_MainMenu_Entry_X5 ; Unused ID
    jp z, .DoPressedUp
        .DoPressedDown:
            ; By exclusion, the last choice is having pressed on a down button
            ; Arrow Down
            ; Use the last visible item as the starting point to find the next 5 entries
            ld hl, wMenu_MainMenu_Entry_EntriesPointers.Entry4
            ld a, [hl+]
            ld b, [hl]
            ld c, a
            ld a, [wMenu_MainMenu_Entry_PageEdge]
            cp Enum_Menu_PAGEEDGE_BOTTOM
            jr nz, .Continue
            .InvalidDown:
                ; We were already at the pageedge bottom, so cancel the down button effect
                ; The entries were not updated
                xor a
                ld [wMenu_MainMenu_Entry_EntriesUpdated], a
                ret
            .Continue:
            ; If we were at the top page edge, then clear it
            xor a
            ld [wMenu_MainMenu_Entry_PageEdge], a
            ld hl, wMenu_MainMenu_Entry_EntriesPointers
            ;jr .DownwardsSearch

            .DownwardsSearch:
                ; bc = some location wMenu_MainMenu_Entry_QuantityTable + offset1
                ;      we search starting from this address for new entries
                ; hl = wMenu_MainMenu_Entry_EntriesPointers + offset2
                inc bc
                ld a, [bc]
                cp $00
                jr z, .CheckNextEntry
                .EntryQuantityNonZero:
                     ; Item has quantity! Save it in hl = wMenu_MainMenu_Entry_EntriesPointers + offset2
                    ld [hl], c
                    inc hl
                    ld [hl], b
                    inc hl
                    ; if (hl - wMenu_MainMenu_Entry_EntriesPointers.End) == 0, then we've reached the end of wMenu_MainMenu_Entry_EntriesPointers
                    ; so we stop
                    ld de, wMenu_MainMenu_Entry_EntriesPointers.End
                    TwosComp de
                    push hl
                    add hl, de
                    ld a, h
                    or l
                    pop hl
                    ret z ; stop if end
                    ;jr .CheckNextEntry

                .CheckNextEntry:
                ; We should check the next entry

                ; Make sure we are not at the end of the quantity table
                ; if (hl - (wMenu_MainMenu_Entry_QuantityTable.End - 1)) == 0, then we are at the end of the table
                ; If we are not at the end of the table, loop and try the next entry
                push hl
                ld hl, wMenu_MainMenu_Entry_QuantityTable
                DerefHL
                ld de, ((xInventory_Items.End - 1)- xInventory_Items) ; Subtract 1 because we increase the value at the start of the loop
                add hl, de
                TwosComp hl
                add hl, bc
                ld a, h
                or l
                pop hl
                .NotEnd:
                    jr nz, .DownwardsSearch
                .QuantityTableEnd:
                    ; We've reached the end of the list but don't have 5 entries

                    ; We shouldn't be allowed to go further down
                    Set8 wMenu_MainMenu_Entry_PageEdge, Enum_Menu_PAGEEDGE_BOTTOM
                    push hl
                    ;Check to see if we found 0 results
                    ; if (hl - wMenu_MainMenu_Entry_EntriesPointers) == 0, then we haven't found anything
                    ld de, wMenu_MainMenu_Entry_EntriesPointers
                    TwosComp de
                    add hl, de
                    ld a, h
                    or l
                    pop hl
                    jr nz, .NullifyUnfilledAddresses
                    .NothingFound:
                        ; No update
                        xor a
                        ld [wMenu_MainMenu_Entry_EntriesUpdated], a
                        ret
                    .NullifyUnfilledAddresses:
                        ;The unfilled addresses will be filled with the address of the entry at index 0
                        ;This is generally an empty entry with an empty string as a name

                        ; Stop the loop if (hl - wMenu_MainMenu_Entry_EntriesPointers.End) == 0
                        push hl
                        ld de, wMenu_MainMenu_Entry_EntriesPointers.End
                        TwosComp de
                        add hl, de
                        ld a, h
                        or l
                        pop hl
                        ret z

                        Get16 bc, wMenu_MainMenu_Entry_QuantityTable
                        ld [hl], c  ;Paste entry index 0
                        inc hl
                        ld [hl], b
                        inc hl
                        jr .NullifyUnfilledAddresses

        .DoPressedUp:
            ld a, [wMenu_MainMenu_Entry_PageEdge]
            cp Enum_Menu_PAGEEDGE_TOP
            jr nz, .UpContinue
            .InvalidUp:
                xor a
                ld [wMenu_MainMenu_Entry_EntriesUpdated], a
                ret
            .UpContinue:
            ; If we were at the top page edge, then clear it
            xor a
            ld [wMenu_MainMenu_Entry_PageEdge], a
            ; Use the top visible item as the starting point to find the next 5 entries in reverse order
            ld hl, wMenu_MainMenu_Entry_EntriesPointers
            ld a, [hl+]
            ld b, [hl]
            ld c, a
            ;Fill this data from #4->#0
            ld hl, wMenu_MainMenu_Entry_EntriesPointers.Entry4

            .UpwardsSearch:
                ; bc = some location wMenu_MainMenu_Entry_QuantityTable + offset1
                ;      we search starting from this address for new entries, decrementing
                ; hl = wMenu_MainMenu_Entry_EntriesPointers + offset2
                dec bc
                ld a, [bc]
                cp $00
                jr z, .UpCheckPreviousEntry
                .UpwardsEntryQuantityNonZero:
                     ; Item has quantity! Save it in hl = wMenu_MainMenu_Entry_EntriesPointers + offset2
                    ld [hl], c
                    inc hl
                    ld [hl], b
                    inc hl
                    ; if(hl - (wMenu_MainMenu_Entry_EntriesPointers.Entry0 + 2) == 0), then we filled .Entry0 so we should stop
                    ld de, (wMenu_MainMenu_Entry_EntriesPointers.Entry0 + 2)
                    TwosComp de             ;if de+hl = 0, then we've added a total of 5 addresses, so we can ret as we've filled all the needed entries
                    push hl
                    add hl, de
                    ld a, h
                    or l
                    pop hl

                    ; Set hl to the previous entry
                    ld de, -4
                    add hl, de ;This does NOT affect the z byte.

                    ret z

                .UpCheckPreviousEntry:
                ; We should check the previous entry

                ; Make sure we are not at the start of the quantity table
                ; if (hl - wMenu_MainMenu_Entry_QuantityTable) == 0, then we are at the end of the table
                ; If we are not at the end of the table, loop and try the previous entry
                push hl
                ld hl, wMenu_MainMenu_Entry_QuantityTable
                DerefHL
                TwosComp hl
                add hl, bc
                ld a, h
                or l
                pop hl
                .QuantityTableNotStart:
                    jr nz, .UpwardsSearch
                .QuantityTableStart:
                    ; We've reached the end of the list but don't have 5 entries

                    ; We shouldn't be allowed to go further up
                    Set8 wMenu_MainMenu_Entry_PageEdge, Enum_Menu_PAGEEDGE_TOP

                    ;Check to see if we found 0 results
                    ; if (hl - wMenu_MainMenu_Entry_EntriesPointers.Entry4) == 0, then we haven't found anything
                    push hl
                    ld de, wMenu_MainMenu_Entry_EntriesPointers.Entry4
                    TwosComp de
                    add hl, de
                    ld a, h
                    or l
                    pop hl
                    ret nz
                    .UpNothingFound:
                        ; Don't update if nothing found
                        xor a
                        ld [wMenu_MainMenu_Entry_EntriesUpdated], a
                        ret

    ; $6A39
Menu_MainMenu_Setup_Rings:
    ; Update the current ring (same, next or previous)
    ; Load the ring's creature data
    ; Apply the equipped relic's stat changes
    ; Show the relics and decide whether the user can move the cursor over the relics and whether the user can open the relics menu
    ; Inputs:
    ;   wMenu_CursorID - Used to determine whether to switch the currently selected ring
    ;   wMenu_MainMenu_CurRing - the current ring
    ; Outputs:
    ;   wMenu_MainMenu_RelicMenuIsDisabled is set to 1 if there are no free relics to select, or else it is 0

    ; Disable the relics menu. We will activate it below if we have at least 1 relic
    xor a
    ld [wMenu_MainMenu_RelicMenuIsDisabled], a

    ; Determine how the Rings option was selected by checking where the cursor is right now
    Battery_On
    Battery_SetBank "XRAM Gamestate"
    ld a, [wMenu_CursorID]
    .CheckCurrentRing:
    cp Enum_Menu_CursorTable_MainMenu_Rings_Ab ; Selected via bottom menu, or quitting relic/ability with B
    jr z, .ChooseCurrentRing
    cp Enum_Menu_CursorTable_MainMenu_Rings_R0 ; Relic changed (changed or removed)
    jr z, .ChooseCurrentRing
    cp Enum_Menu_CursorTable_MainMenu_Rings_R1 ; Unknown
    jr nz, .CheckNextRing
    ;jr z, .ChooseCurrentRing                       ; Relic changed (changed or removed)
        .ChooseCurrentRing:
            ; Don't change the currently selected ring. ("Rings" selected, or quitting ability or relic menu, or selecting/removing a relic)
            Get8 c, wMenu_MainMenu_CurRing
            ld b, $00
            ld hl, xInventory_Rings
            add hl, bc
            ld a, [hl]
            jr .RingIsSelected
    .CheckNextRing:
    cp Enum_Menu_CursorTable_MainMenu_Rings_Dn ; Selected by pressing on the Down arrow button
    jr nz, .ChooseUpArrowRing
        .ChooseNextRing:
            ; Get the next ring (Down arrow button was pressed)
            ; Skip the null rings

            ; Get the address of the current ring
            Get8 c, wMenu_MainMenu_CurRing
            ld b, $00
            ld hl, xInventory_Rings
            add hl, bc
            .GetNextRing:
                ; Get the next ring
                inc hl
                ld a, [wMenu_MainMenu_CurRing]
                inc a
                ld [wMenu_MainMenu_CurRing], a

                ; if(hl == xInventory_Rings.End)
                ;     then we've overflowed to the end of the ring's list
                ;     therefore we should reset back to the very first ring located at xInventory_Rings
                ld bc, xInventory_Rings.End
                TwosComp bc
                push hl
                add hl, bc
                ld a, h
                or l
                pop hl
                jr nz, .CheckValidRing1
                .Overflowed1:
                    ; Roll back to first ring
                    xor a
                    ld [wMenu_MainMenu_CurRing], a
                    ld hl, xInventory_Rings
                .CheckValidRing1:
                ;If the xth ring is null, check the (x+1)th ring instead
                ld a, [hl]
                cp xInventory_Rings_NORING
                jr z, .GetNextRing
            jr .RingIsSelected
        .ChooseUpArrowRing:
            ; a == Enum_Menu_CursorTable_MainMenu_Rings_Up
            ; Get the previous ring (Up arrow button was pressed)
            ; Skip the null rings

            ; Get the address of the current ring
            Get8 c, wMenu_MainMenu_CurRing
            ld b, $00
            ld hl, xInventory_Rings
            add hl, bc
            .GetPreviousRing:
                ; Get the previous ring
                dec hl
                ld a, [wMenu_MainMenu_CurRing]
                dec a
                ld [wMenu_MainMenu_CurRing], a

                ; if(hl == xInventory_Rings-1)
                ;     then we've overflowed past the beginning of the ring's list
                ;     therefore we should reset back to the very last ring located at xInventory_Rings.End - 1
                ld bc, xInventory_Rings - 1
                TwosComp bc
                push hl
                add hl, bc
                ld a, h
                or l
                pop hl
                jr nz, .CheckValidRing2
                .Overflowed2:
                    ; Roll forward to last ring
                    Set8 wMenu_MainMenu_CurRing, (xInventory_Rings_LENGTH - 1)
                    ld hl, xInventory_Rings.End - 1
                .CheckValidRing2:
                ;If the xth ring is null, check the (x-1)th ring instead
                ld a, [hl]
                cp CreatureID_Null
                jr z, .GetPreviousRing  ;Ring was empty
            jr .RingIsSelected ; inefficiency - line not needed

    .RingIsSelected:
    ; c = a = ring's structure id
    ; Find the address of the creature's struct and get the ID (creature type)
    ld c, a
    ld b, Creature_SIZE
    call Math_Mult
    Battery_SetBank "XRAM Creatures"
    ld bc, xCreature_00_Hero.ID
    add hl, bc
    push hl

    ; Get the creature's name
    Set8 wBattle_CopyBuffer_ListIndex, [hl]
    Battery_Off
    ld bc, wMenu_MainMenu_CurCreatureName
    FSet16 wBattle_CopyBuffer_Destination, bc
    Do_CallForeign CreatureName_CopyToDest
    ; Paste it into the tileset
    ld hl, wMenu_MainMenu_CurCreatureName
    Set16 wMenu_MainMenu_StringToTileset_Source, hl
    ld bc, Menu_MainMenu_VRAM_RINGS_NAME
    FSet16 wMenu_MainMenu_StringToTileset_Dest, bc
    Set8 wMenu_MainMenu_StringToTileset_Length, CreatureName_SIZE
    call Menu_MainMenu_StringToTileset

    ; Load the Stats Header
    call Menu_MainMenu_LoadStatsHeaders.Creature

    ; Navigate to the creature's 6 stats
    pop hl ; Creature struct
    push hl
    SwitchRAMBank BANK(wBattle_Creature_Target)
    ld bc, (xCreature_00_Hero.Strength - xCreature_00_Hero)
    add hl, bc
    ; Copy the 6 stats into wBattle_Creature_Target, because the relics apply their effects to the structure located at wBattle_Creature_Target
    ld bc, wBattle_Creature_Target.Strength
    Battery_SetBank "XRAM Creatures"
    Battery_On
    ld d, ((xCreature_00_Hero.Luck + 1) - xCreature_00_Hero.Strength)
    .CopyLoop1:
        LdBCIHLI
        dec d
        jr nz, .CopyLoop1

    ; Navigate to the creature's 2 relics
    pop hl
    push hl
    ld bc, (xCreature_00_Hero.Relic0 - xCreature_00_Hero)
    add hl, bc
    ; Copy the 2 relic ids into wBattle_Creature_Target, because the relics are read from this structure
    ld bc, wBattle_Creature_Target.Relic0
    LdBCIHLI
    LdBCIHLI
    Battery_Off

    ; Apply the effects of the relics to the creature's stats
    Do_CallForeign ApplyRelicsCmd1Stats

    ; Copy the 6 stats back to WRAM0 (not strictly necessary?)
    ld hl, wBattle_Creature_Target.Strength
    ld bc, wMenu_Battle_TableRowBuffer
    ld d, ((xCreature_00_Hero.Luck + 1) - xCreature_00_Hero.Strength)
    .CopyLoop2:
        LdBCIHLI
        dec d
        jr nz, .CopyLoop2

    ; Copy the 6 stats into the tilemap
    xor a
    ld [rVBK], a
    ld a, [wMenu_Battle_TableRowBuffer.Strength]  ;Copy the stat numbers into the tilemap
    ld hl, WINDOW_COORD_04_0A
    call Menu_MainMenu_SetTilemap2DigitNumber
    ld a, [wMenu_Battle_TableRowBuffer.Skill]
    ld hl, WINDOW_COORD_04_11
    call Menu_MainMenu_SetTilemap2DigitNumber
    ld a, [wMenu_Battle_TableRowBuffer.Speed]
    ld hl, WINDOW_COORD_06_0A
    call Menu_MainMenu_SetTilemap2DigitNumber
    ld a, [wMenu_Battle_TableRowBuffer.Defence]
    ld hl, WINDOW_COORD_05_0A
    call Menu_MainMenu_SetTilemap2DigitNumber
    ld a, [wMenu_Battle_TableRowBuffer.Resist]
    ld hl, WINDOW_COORD_05_11
    call Menu_MainMenu_SetTilemap2DigitNumber
    ld a, [wMenu_Battle_TableRowBuffer.Luck]
    ld hl, WINDOW_COORD_06_11
    call Menu_MainMenu_SetTilemap2DigitNumber

    ; Get the creature's Level, Experience, MaxEnergy
    pop hl
    push hl
    ld bc, (xCreature_00_Hero.Level - xCreature_00_Hero)
    add hl, bc
    ld bc, wMenu_Battle_TableRowBuffer
    Battery_SetBank "XRAM Creatures"
    Battery_On
    LdBCIHLI   ; Level
    LdBCIHLI   ; Experience (big-endian)
    LdBCIHLI
    inc hl
    inc hl
    LdBCIHLI   ; MaxEnergy (big-endian)
    LdBCIHLI
    Battery_Off
    ; Copy the Level, Experience, MaxEnergy into the tilemap
    ld a, [wMenu_Battle_TableRowBuffer.Level]
    ld hl, WINDOW_COORD_03_0A
    call Menu_MainMenu_SetTilemap2DigitNumber
    ld a, [wMenu_Battle_TableRowBuffer.Experience + 1] ; Get the lower byte
    ld hl, WINDOW_COORD_03_11
    call Menu_MainMenu_SetTilemap2DigitNumber
    ; Max Energy
    FGet16_BigEndian de, wMenu_Battle_TableRowBuffer.MaxEnergy
    call Math_ConvertNumberToDigits
    ld hl, WINDOW_COORD_09_0F
    ld d, Menu_MainMenu_TILEID_NUMBERS
    call Menu_MainMenu_SetTilemap3DigitNumber

    ; Write the 2 relics' names (skip the first char "‚ùì")
    ld bc, Menu_MainMenu_VRAM_RINGS_RELIC0
    FSet16 wMenu_MainMenu_StringToTileset_Dest, bc
    pop hl
    push hl
    ld bc, (xCreature_00_Hero.Relic0 - xCreature_00_Hero)
    call Menu_MainMenu_SetRelicString

    ld bc, Menu_MainMenu_VRAM_RINGS_RELIC1
    FSet16 wMenu_MainMenu_StringToTileset_Dest, bc
    pop hl
    push hl
    ld bc, (xCreature_00_Hero.Relic1 - xCreature_00_Hero)
    call Menu_MainMenu_SetRelicString

    ; Draw the creature's card.
    ; Get the ID
    pop hl
    push hl
    Battery_SetBank "XRAM Creatures"
    Battery_On
    Set8 wTemp_8.Fightscene_CreatureID, [hl] ;id
    Battery_Off
    Do_CallForeign Cardscene_GetCardIcon      ;Get the address of the card tileset
    ld bc, Menu_MainMenu_VRAM_RINGS_CARD
    FSet16 wVBlank_DestAddress, bc
    Set8 wMenu_MainMenu_TempIndex, $14 ; Loop counter - Card tileset is $14 bytes
    .CopyCardTile:
        Get8 e, wVBlank_Bank
        ld hl, Interrupt_VBlankFunc_CopyTile
        call CallForeign
        ld hl, wMenu_MainMenu_TempIndex
        dec [hl]
        jr nz, .CopyCardTile

    ; Enable cursor access to the two relics by default
    ld hl, wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Rings_R0
    ld a, $01
    ld [hl+], a
    ld [hl+], a

    ; But now loop through all relics to see if we have at least 1 relic in Tony's inventory
    Battery_SetBank "XRAM Gamestate"
    Battery_On
    ld hl, xInventory_Relics
    ld d, (xInventory_Relics.End - xInventory_Relics) - 1 ; bug - value should be incremented by 1 to check all relics. Alternatively, hl should start at (xInventory_Relics+1) to avoid checking Relic_NULL
    xor a
    .LoopRelicCheck:
        or [hl]
        inc hl
        dec d
        jr nz, .LoopRelicCheck
    push af
    Battery_Off
    pop af

    ; If a is non-zero, then we found at least 1 relic
    ; So we can keep the enabled cursor access
    and a
    pop hl
    .RelicsFound:
        ret nz
    .NoRelicsFound:
        ; No relics found!
        ; Disable the relic menu
        push hl
        Set8 wMenu_MainMenu_RelicMenuIsDisabled, $01
        ; However, if the Dream creature has non-null relics, then we should be able to move our cursor over them to deselect them
        ; Store the 2 relic ids into wMenu_MainMenu_CursorTableValidIDs, so that if the relic id is non-zero, we can mouse over
        Battery_SetBank "XRAM Creatures"
        Battery_On
        xor a
        pop hl
        ld bc, (xCreature_00_Hero.Relic0 - xCreature_00_Hero)
        add hl, bc
        ; Relic0
        or [hl]
        inc hl
        ld bc, wMenu_MainMenu_CursorTableValidIDs + Enum_Menu_CursorTable_MainMenu_Rings_R0
        ld [bc], a
        ; Relic1
        inc bc
        xor a
        or [hl]
        ld [bc], a
        Battery_Off
        ret

    ; $6C9D
Menu_MainMenu_Save:
    ; Called when selecting the Save
    ; Inputs:
    ;   wMenu_MainMenu_IsInOverworld - If Tony is not in the overworld, it will use the Eldritch Awl instead of saving
    ;       This seems to be a removed feature from that's likely unused
    ld a, [wMenu_MainMenu_IsInOverworld]
    and a
    jr z, .NotOverworld
    .InOverworld:
        ; Save the game
        Script_Set wScript_System, Script_Save
        ret
    .NotOverworld:
        ; Sets up Eldritch Awl
        Script_Set wScript_System, _TODO_ELDRITCHAWL
        ret
    ret ; unused

    ; $6CCA
Menu_MainMenu_Setup_Ability:
    ; Looks up a Dream creature's ring and writes the unlocked abilities and the energy cost
    ; Inputs:
    ;   wMenu_MainMenu_CurRing (0-9) for the ring's abilities to select

    ; Find the current creature structure and navigate to the abilities
    ; CreatureID = [xInventory_Rings + wMenu_MainMenu_CurRing]
    ; Creature_Struct -> [xCreature_00_Hero + CreatureID*Creature_SIZE]
    ; Creature.Ability0
    xor a
    ld [rVBK], a
    Battery_SetBank "XRAM Gamestate"
    Battery_On
    ld a, [wMenu_MainMenu_CurRing] ;Take selected ring number
    ld c, a
    ld b, $00
    ld hl, xInventory_Rings
    add hl, bc
    ld a, [hl]                     ;Find corresponding ring data
    ld c, a
    ld b, Creature_SIZE
    call Math_Mult
    ld bc, xCreature_00_Hero.Ability0
    add hl, bc

    ; Copy the 4 abilities and unlock levels into a buffer
    ld bc, wMenu_MainMenu_CurCreatureAbilityBuffer
    Battery_SetBank "XRAM Creatures"
    ld d, (wMenu_MainMenu_CurCreatureAbilityBuffer.End - wMenu_MainMenu_CurCreatureAbilityBuffer)
    .CopyLoop:
        LdBCIHLI
        dec d
        jr nz, .CopyLoop
    Battery_Off

    ; Count the number of unlocked abilities (from 1 to 4). An ability is unlocked if the level requirement is Creature_Ability_UNLOCKED
    ld hl, wMenu_MainMenu_CurCreatureAbilityBuffer.AbilityUnlock0
    ld d, $00
    .CheckLoop:
        ld a, [hl+]
        cp Creature_Ability_UNLOCKED
        jr nz, .AbilityCountEnd
        inc d
        cp $04 ; There are max 4 abilities
        jr nz, .CheckLoop
    .AbilityCountEnd:
    Set8 wMenu_MainMenu_UnlockedAbilities, d


    ; Loop over the 4 abilities
    ld bc, wMenu_Battle_TableRowBuffer ; Used for BattleCmd_GetNameAndEnergy
    FSet16 wMenu_BattleCmd_DestBuffer, bc
    xor a
    ld [wMenu_MainMenu_TempIndex], a ; Loop count, 0-3
    .LoopGetNextAbility:
        ; Get the pointer for Ability0 - Ability3, depending on loop count
        ld hl, wMenu_MainMenu_CurCreatureAbilityBuffer.Ability0
        ld a, [wMenu_MainMenu_TempIndex]
        add a
        ld c, a
        ld b, $00
        add hl, bc
        DerefHL

        ; Get the ability name and energy cost
        Set16 wMenu_BattleCmd_TablePointer, hl
        Set8 wMenu_BattleCmd_GetEnergyFlag, Menu_GetAbility_GETENERGY_TRUE
        Do_CallForeign BattleCmd_GetNameAndEnergy

        ; Copy the ability's name into the tileset
        ; The location in the tileset is offset based on the loop count
        ld bc, wMenu_Battle_TableRowBuffer.AbilityName
        FSet16 wMenu_MainMenu_StringToTileset_Source, bc
        Set8 wMenu_MainMenu_StringToTileset_Length, BATTLECMD_STRUCT_NAMESIZE
        ld b, (Menu_MainMenu_VRAM_ABILITY_ABILITY1 - Menu_MainMenu_VRAM_ABILITY_ABILITY0)
        Get8 c, wMenu_MainMenu_TempIndex
        call Math_Mult
        ld bc, Menu_MainMenu_VRAM_ABILITY_ABILITY0
        add hl, bc
        Set16 wMenu_MainMenu_StringToTileset_Dest, hl
        call Menu_MainMenu_StringToTileset

        ; Convert the energy cost into 3 digits
        ld hl, wMenu_Battle_TableRowBuffer.AbilityEnergyCost
        xor a
        ld e, [hl]
        cp e
        jr z, .ZeroCost
        .NonZeroCost:
            ld d, $00
            call Math_ConvertNumberToDigits
            jr .Continue
        .ZeroCost:
            ; If the cost is zero, we will write 3 blank spaces "   "
            ld a, Textbox_TILEID_BLANK - Menu_MainMenu_TILEID_NUMBERS
            ld hl, wX1
            ld [hl+], a
            ld [hl+], a
            ld [hl+], a
        .Continue:

        ; We don't need the data in wMenu_Battle_TableRowBuffer anymore, so let's reuse it for something else
        ; Convert the 3 digits into tileids and store it in wMenu_Battle_TableRowBuffer
        xor a
        ld [rVBK], a
        ld hl, wMenu_Battle_TableRowBuffer
        ld d, Menu_MainMenu_TILEID_NUMBERS
        call Menu_MainMenu_SetTilemap3DigitNumber

        ; Calculate where to write the energy cost
        ; Offset the location by Y += 2 depending on the loop count
        ld c, (WINDOW_COORD_06_10 - WINDOW_COORD_04_10)
        Get8 b, wMenu_MainMenu_TempIndex
        call Math_Mult
        ld bc, WINDOW_COORD_04_10
        add hl, bc

        ; Copy the energy cost into the tilemap
        ld bc, wMenu_Battle_TableRowBuffer
        LdHLIBCI
        LdHLIBCI
        LdHLIBCI

        ; Loop to the next ability, to a max of 4
        ld hl, wMenu_MainMenu_TempIndex
        inc [hl]
        ld a, [wMenu_MainMenu_UnlockedAbilities]
        cp [hl]
        jp nz, .LoopGetNextAbility
        ; If we have written all 4 abilities, there are no abilities to blank out, so ret here and don't do the next section of code
        ld a, [hl]
        cp $04
        ret z

    ; For the hidden abilities (the ones that are not displayed)
    ; Replaces them all with blank tiles
    xor a
    ld [rVBK], a
    .LoopBlank:
        ; Offset the location by Y += 2 depending on the loop count
        Get8 c, wMenu_MainMenu_TempIndex
        ld b, (WINDOW_COORD_06_02 - WINDOW_COORD_04_02)
        call Math_Mult

        ; Blank out the name
        ld bc, WINDOW_COORD_04_02
        add hl, bc
        ld d, BATTLECMD_STRUCT_NAMESIZE
        ld a, Textbox_TILEID_BLANK
        .Copy7Tiles:
            ld [hl+], a
            dec d
            jr nz, .Copy7Tiles
        ; Loop until all 4 abilities have been processed
        ld hl, wMenu_MainMenu_TempIndex
        inc [hl]
        ld a, $04
        cp [hl]
        jp nz, .LoopBlank
    ret

    ; $6DDF
Menu_MainMenu_UseSelected::
    ; Called from MenuFunc_MainMenu
    ; For Spell, Relic, Item or Save
    ; Given a MenuOptionID, figures out the selected entry, returning the index ID
    ;   as well as saving the text of the entry name
    ; Thread2 is set to use the entry or Save, except in the case of a relic
    ; Inputs:
    ;   wMenu_CursorID - determines where the cursor was when pressing A
    ;   wMenu_MainMenu_CurrentMenu - used to determine entry type (Spell/Relic/Item)
    ; Outputs:
    ;   $C723?
    ;   $C725?
    ;   wMenu_MainMenu_EquippingRelic and $C724 - index of the selected entry
    ;   If not a relic:
    ;       wText_StringFormatFrame - Name of entry, terminated by <FORMAT>üîä
    ;       Thread2 is set to use the item or spell

    ; Figure out if the selection was a Save, Spell, Relic or Item
    ld a, [wMenu_CursorID]
    .CheckSave:
    cp Enum_Menu_CursorTable_MainMenu_Save
        .DoSave:
            jp z, Menu_MainMenu_Save

    .CheckGlyph:
    ; TODO - what is this check for? Need to check the item/spell scripts to see
    cp Enum_Menu_CursorTable_MainMenu_Glyph
    jr nz, .NotGlyph
    .Glyph:
        ; Unused - Opening the glyph doesn't pass through this function
        ld a, $00
        jr Continue
    .NotGlyph:
        ; Spell, Item, Relic
        ld a, $03
    Continue:
    ld [$C723], a ; TODO - what is this for? Need to check the item/spell scripts to see

    ; Get the collision tile that the hero is on
    FGet16 hl, wActor_Hero.TileAddress
    PushRAMBank
    SwitchRAMBank BANK(wCollisionMap)
    Set8 $C725, [hl] ; TODO - possibly this is to determine if we can use the item (e.g. not allowed if not on land?)
    PopRAMBank

    ; Get the inventory quantity address of the selected item
    Get8 b, wMenu_MainMenu_Entry_TopChoiceCursorID
    ld a, [wMenu_CursorID]
    sub b
    add a
    ld c, a
    ld b, $00
    ld hl, wMenu_MainMenu_Entry_EntriesPointers
    add hl, bc
    DerefHL

    ; Item Index = InventoryQuantityAddress - [wMenu_MainMenu_Entry_QuantityTable]
    Get16 bc, wMenu_MainMenu_Entry_QuantityTable
    TwosComp bc
    add hl, bc

    ; Store the index (just in case it is a relic) into wMenu_MainMenu_EquippingRelic
    ld b, l
    ld a, l
    ld [wMenu_MainMenu_EquippingRelic], a
    ld [$C724], a ; TODO $C724

    ;Copies the data entry into the buffer. Applies to Spells/Items. For relics, this returns garbage data as the table width is not $22
    ld c, ItemSpell_ROWSIZE
    call Math_Mult
    Get16 bc, wMenu_MainMenu_Entry_EntryDataTable
    add hl, bc
    Set16 wBattle_CopyBuffer_Source, hl
    ld bc, wMenu_Battle_TableRowBuffer
    FSet16 wBattle_CopyBuffer_Destination, bc
    Do_CallForeign ItemSpell_GetDataFromAddress

    ; For relics, end here. The only thing we had cared about was setting wMenu_MainMenu_EquippingRelic
    ld a, [wMenu_MainMenu_CurrentMenu]
    cp Menu_MainMenu_ID_RELIC
    ret z

    ; Continue for Items and Spells
    ; Check to see if the item/spell has a script pointer for map useage
    FGet16 hl, wMenu_Battle_TableRowBuffer.ItemSpell_MapAddress
    ld a, h
    or l
    jr z, .NullPointer
    .ValidPointer:
        Script_Set_Var wScript_System, wMenu_Battle_TableRowBuffer.ItemSpell_MapBank, wMenu_Battle_TableRowBuffer.ItemSpell_MapAddress
        ; jr .CopyName

        ; Format the name of the item so that the script can use it if needed
        .CopyName:
            ld hl, wMenu_Battle_TableRowBuffer.ItemSpell_Name
            Set16_M wText_StringFormatFrame, wText_StringBuffer
            ld bc, wText_StringBuffer
            ld d, ItemSpell_NAMESIZE
            .CopyNameLoop:
                LdBCIHLI
                dec d
                jr nz, .CopyNameLoop

            ld a, "üîä" ;Add üîä<FORMAT> to the end
            ld [bc], a
            inc bc
            ret
    .NullPointer:
        ;address is null $0000, so give error instead
        Script_Set_Var wScript_System, wInventory_ItemSpellMapDefaultScript.Bank, wInventory_ItemSpellMapDefaultScript.Address
        ; Save the item name
        jr .CopyName

    ; $6EBB
Menu_MainMenu_SetTilemapString::
    ; Writes sequential tile numbers onto the tilemap, which basically
    ; copies a tileset string into the tilemap
    ; Inputs:
    ;   a - Tile number of first character of the string
    ;   c - String length
    ;   hl - Destination address
    ;   de - Delta of the destination address between each character
    .Loop:
        ld [hl], a
        add hl, de
        inc a
        dec c
        jr nz, .Loop
    ret

    ; $6EC2
Menu_MainMenu_VRAMDebugInitialize::
    ; Initializes the VRAM tiles reserved for the upper part of the menu
    ; with debug text to help a developer identify bugs or make a tilemap
    ; The player should never see the debug string
    Set8 wMenu_MainMenu_CurrentMenu, Menu_MainMenu_ID_DEBUG
    jp Menu_MainMenu_DrawCurrentTop


    ; $6ECA
TILEMAP_Menu_MainMenu_Top_GlyphEmpty::
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/GlyphEmpty.tilemap"

    ; $6F92
TILEMAP_GlyphCoreStone5::
    ; Width 4, Height 4
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/glyph/GlyphCoreStone5.tilemap"

    ; $6FA6
TILEMAP_GlyphCoreStone1::
    db $2A, $2B
    ; $6FA8
TILEMAP_GlyphCoreStone2::
    db $2C
    ; $6FA9
TILEMAP_GlyphCoreStone3::
    db $2D
    ; $6FAA
TILEMAP_GlyphCoreStone4::
    db $2E, $2F
    ; $6FAC
ATTRMAP_GlyphEmpty::
    ; $0C wide, $08 tall
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/glyph/GlyphEmpty.attrmap"
    ; $700C
ATTRMAP_GlyphCoreStone5::
    ; Width 4, Height 4
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/glyph/GlyphCoreStone5.attrmap"
    ; $7020
ATTRMAP_GlyphCoreStone1::
    ; UNUSED - hardcoded in Menu_MainMenu_DrawAttrmapTop
    db $0F, $0F
    ; $7022
ATTRMAP_GlyphCoreStone2::
    ; UNUSED - hardcoded in Menu_MainMenu_DrawAttrmapTop
    db $0F
    ; $7023
ATTRMAP_GlyphCoreStone3::
    ; UNUSED - hardcoded in Menu_MainMenu_DrawAttrmapTop
    db $0F
    ; $7024
ATTRMAP_GlyphCoreStone4::
    ; UNUSED - hardcoded in Menu_MainMenu_DrawAttrmapTop
    db $0F, $0F

    ; $7026
TILEMAP_Menu_MainMenu_Top_Tony_::
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/Tony_.tilemap"
    ; $70EE
TILEMAP_Menu_MainMenu_Top_Rings::
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/Rings.tilemap"
    ; $71B6
TILEMAP_Menu_MainMenu_Top_GenericList::
    ; Spells, Items, Relics all share the exact same tilemap
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/GenericList.tilemap"
    ; $727E
TILEMAP_Menu_MainMenu_Top_Ability::
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/Ability.tilemap"
    ; $7346
TILEMAP_Menu_MainMenu_Top_UnusedList::
    ; Unused - Has 5 entries of length $0C (that's the length of an item/spell)
    ;          and 2 tiles after the name to display ?energy cost/quantity
    ; There are no arrow buttons available, so this could possibly also be previously intended for Tony's upgrades?
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/UnusedList.tilemap"
    ; $740E
TILEMAP_Menu_MainMenu_Top_InfusedList::
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/InfusedList.tilemap"


    ; These 5 abilities need to be in order as they are loaded in a block
    ; $74D6
BITMAP_Menu_MainMenu_Abilities_EnergyBand::
    INCBIN "autogenerated/assets/menu/mainmenu/abilities/EnergyBand.tileset"
    .End
    ; $7566
BITMAP_Menu_MainMenu_Abilities_CrystalGloves::
    INCBIN "autogenerated/assets/menu/mainmenu/abilities/CrystalGloves.tileset"
    .End
    ; $75F6
BITMAP_Menu_MainMenu_Abilities_AgadonsBoots::
    INCBIN "autogenerated/assets/menu/mainmenu/abilities/AgadonsBoots.tileset"
    .End
    ; $7686
BITMAP_Menu_MainMenu_Abilities_OrotheanBelt::
    INCBIN "autogenerated/assets/menu/mainmenu/abilities/OrotheanBelt.tileset"
    .End
    ; $7716
BITMAP_Menu_MainMenu_Abilities_EyeOfTheStorm::
    INCBIN "autogenerated/assets/menu/mainmenu/abilities/EyeOfTheStorm.tileset"
    .End

    ; These 6 stats need to be in order as they are loaded in a block
    ; $77A6
BITMAP_Menu_MainMenu_Stats_Strngth::
    INCBIN "autogenerated/assets/menu/mainmenu/stats/Strngth.tileset"
    .End
    ; $77E6
BITMAP_Menu_MainMenu_Stats_Defense::
    INCBIN "autogenerated/assets/menu/mainmenu/stats/Defense.tileset"
    .End
    ; $7826
BITMAP_Menu_MainMenu_Stats_Speed::
    INCBIN "autogenerated/assets/menu/mainmenu/stats/Speed.tileset"
    .End
    ; $7866
BITMAP_Menu_MainMenu_Stats_Skill::
    INCBIN "autogenerated/assets/menu/mainmenu/stats/Skill.tileset"
    .End
    ; $78A6
BITMAP_Menu_MainMenu_Stats_Resist::
    INCBIN "autogenerated/assets/menu/mainmenu/stats/Resist.tileset"
    .End
    ; $78E6
BITMAP_Menu_MainMenu_Stats_Luck::
    INCBIN "autogenerated/assets/menu/mainmenu/stats/Luck.tileset"
    .End

    ; These 2 stats need to be in order as they are loaded in a block
    ; $7926
BITMAP_Menu_MainMenu_Stats_Level::
    INCBIN "autogenerated/assets/menu/mainmenu/stats/Level.tileset"
    .End
    ; $7966
BITMAP_Menu_MainMenu_Stats_Exprnce::
    INCBIN "autogenerated/assets/menu/mainmenu/stats/Exprnce.tileset"
    .End

    ; $79A6
BITMAP_Menu_MainMenu_Glyph::
    INCBIN "autogenerated/assets/menu/mainmenu/top_tilemaps/glyph/Glyph.tileset"
    .End
    ; $7E06
