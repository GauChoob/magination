import logging
import os
import pathlib
import shutil
import re
import make.utils as utils
import projutils.color as color
import projutils.tilemap as tilemap
import projutils.tileset as tileset
import projutils.pattern as pattern
import projutils.hotspot as hotspot
import magiparser

FOLDERS = [
    'assets\\',
    'magiscript\\',
    ]
RLE_EXTENSIONS = [
    r'tilemap',
    r'attrmap',
    r'pal',
    r'tileset',
    r'collision\.tilemap',
    r'metatile\.tilemap',
    r'pattern',
]

# Include *RLEn.ext          n = 0-9A-Z
# Exclude *.RLE              ext = only if listed in the list above
RLE_REGEX = r"^(.*)RLE([0-9A-Z])\.(?!rle)({})$".format('|'.join(RLE_EXTENSIONS))


def convert_to_processed_name(filename: str | pathlib.Path):
    """Converts an original filename to a processed filename.
    Returns (filename, filename_rle), where the first string is the processed filename, ignoring RLE,
    and the second string also fixes the RLE if it exists."""
    def parse_end(filename: str | pathlib.Path):
        if filename.endswith('.tileset.png'):
            return os.path.splitext(filename)[0]
        elif filename.endswith('.pal.png'):
            return os.path.splitext(filename)[0]
        elif filename.endswith('.pattern.tilemap'):
            return os.path.splitext(filename)[0]
        elif filename.endswith('.pattern.attrmap'):
            return False
        elif filename.endswith('.tilemap'):
            return filename
        elif filename.endswith('.attrmap'):
            return filename
        elif filename.endswith('.mgi'):
            return filename + '.asm'
        elif filename.endswith('.hs'):
            return filename + '.asm'
        elif filename.endswith('.trig'):
            return filename + '.asm'
        return False

    def parse_rle(filename: str | pathlib.Path):
        matchobj = re.match(RLE_REGEX, filename)
        if not matchobj:
            return filename
        basename = matchobj.group(1)
        ext = matchobj.group(3)
        return basename + '.' + ext + ".rle"

    filename = os.path.join('autogenerated\\', filename)
    filename = parse_end(filename)
    if not filename:
        return (False, False)
    filename_rle = parse_rle(filename)
    return (filename, filename_rle)


def delete_all():
    logging.debug('Deleting autogenerated assets files')
    for folder in FOLDERS:
        auto_folder = os.path.join('autogenerated\\', folder)
        if os.path.exists(auto_folder):
            shutil.rmtree(auto_folder)


def build():
    # Get a list of all the processed files and their build time
    processed_files = {}
    for folder in FOLDERS:
        auto_folder = os.path.join('autogenerated\\', folder)
        for header, dirs, files in os.walk(auto_folder):
            for file in files:
                file_path = os.path.join(header, file)
                processed_files[file_path] = utils.get_last_modified(file_path)

    # Now iterate through all the original files and update the files that don't have a processed file or who have been modified since the processed file was created
    # Note that this can fail if you change a file's compression format (RLEX) or if you rename it and overwrite an old file during the rename
    # In which case you probably want to delete_all() and then start from scratch
    for folder in FOLDERS:
        for header, dirs, files in os.walk(folder):
            for file in files:
                if file[-15:] == 'pattern.attrmap':
                    # Only process pattern.tilemap, not pattern.attrmap (special case)
                    continue

                # Get the file_time of the processed file and cross it off the list
                file_path = os.path.join(header, file)
                file_path_processed, file_path_processed_rle = convert_to_processed_name(file_path)
                if not file_path_processed:
                    # Skip files that shouldn't be processed
                    continue

                # Get the file_time of the current file
                processed_time = processed_files.pop(file_path_processed_rle, 0)
                file_time = utils.get_last_modified(file_path)
                if file_path[-15:] == 'pattern.tilemap':
                    # Pattern special case where two files (pattern.tilemap/attrmap) are merged into one - get the oldest file_time
                    file_path_attr = file_path[:-7] + 'attrmap'
                    file_time = max(file_time, utils.get_last_modified(file_path_attr))

                # Skip if file doesn't need to be recreated
                if processed_time > file_time:
                    continue

                # Make the processed file
                logging.debug(file_path_processed_rle)
                os.makedirs(os.path.dirname(file_path_processed), exist_ok=True)
                if file_path.endswith('.tileset.png'):
                    tileset.Bitmap.init_from_original_file(file_path).save_processed_file(file_path_processed)
                elif file_path.endswith('.pal.png'):
                    color.Palette.init_from_original_file(file_path).save_processed_file(file_path_processed, True)
                elif file_path.endswith('.pattern.tilemap'):
                    pattern.Pattern.init_from_original_file(file_path).save_processed_file(file_path_processed)
                elif file_path.endswith('.tilemap'):
                    tilemap.Tilemap.init_from_original_file(file_path).save_processed_file(file_path_processed)
                elif file_path.endswith('.attrmap'):
                    tilemap.Tilemap.init_from_original_file(file_path).save_processed_file(file_path_processed)
                elif file_path.endswith('.mgi'):
                    magiparser.convert(file_path, file_path_processed)
                elif file_path.endswith('.hs'):
                    hotspot.Hotspot.file_to_hotspot(file_path, file_path_processed)
                elif file_path.endswith('.trig'):
                    hotspot.Trigger.file_to_trigger(file_path, file_path_processed)
                else:
                    raise KeyError

    # The processed files that were never checked don't have a corresponding original file anymore, so we delete them
    for file in processed_files:
        logging.debug('Deleting: ' + file)
        os.remove(file)


def do():
    logging.info('Processing asset and magiscript files...')
    build()
