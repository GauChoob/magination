import os
import re
import shutil
from typing import List
import projutils.utils as utils
import projutils.config as config

# This module takes virgin .asm files autogenerated by mgbdis and determines where an asset would fit.
# It then excises the code/db/structures that are in the way and replaces it with custom text
#
# e.g. You want to replace address 0x5000-0x5100 in bank 0x54 with an image
# replace_rom_text(0x54,0x5000,0x51000,"testImage:",'    INCBIN "testImage.2bpp"')

SOURCEDIR = "source/banks/"
OUTDIR = config.outdir + "banks/"
os.makedirs(OUTDIR, exist_ok=True)


class Line:
    def __init__(self, address: int, size: int, data: List[int], raw: str, type: str):
        """Metadata about a line of text in the .asm file"""
        self.address = address
        self.address_end = address + size
        self.size = size
        self.data = data
        self.raw = raw
        self.type = type

    def __str__(self):
        return "{} {} {} {} \n{}".format(utils.AsmWords(self.address, 0), self.size, self.type, self.data, self.raw)


def _findNextAddress(lines_meta: List[Line], j: int) -> int:
    """Finds the address of the next Line object after index j that has a defined address"""
    jmax = len(lines_meta)
    while j < jmax:
        j += 1
        if lines_meta[j].type == "UNKNOWN":
            return -1
        elif lines_meta[j].address >= 0:
            return lines_meta[j].address


def _findLastAddress(lines_meta: List[Line]) -> int:
    """Finds the most distal Line object that has a defined address
    (some Line objects of size = 0 don't have a defined address so we need to skip them)"""
    i = len(lines_meta)
    while i > 0:
        i -= 1
        if lines_meta[i].type == "UNKNOWN":
            return -1
        elif lines_meta[i].address_end >= 0:
            return lines_meta[i].address_end
    return -1


def _build_line_metadata(lines_source: List[str]) -> List[Line]:
    """Parses all the lines of a .asm file into a list of Line objects with metadata.
    This way we keep track of the address of each line"""

    def remove_comments(line: str) -> str:
        """Strips out the comment from a line"""
        i = line.find(";")
        if i >= 0:
            line = line[:i]
        return line

    def confirmSequential(lines_meta: List[Line]) -> bool:
        """Runs through all the lines to make sure the calculated address makes sense.
        That is, the address_end of each line corresponds to the address of the next line.
        We allow the address to jump if the line's address was manually defined.
        Returns True if no instances of jumping backwards in address"""
        addr = 0x4000
        for line in lines_meta:
            if line.address >= 0:
                if line.address < addr:
                    # Makes no sense - jumping back in address - return False
                    print("Failed on line:")
                    print(line.raw)
                    return False
                if line.address > addr:
                    # Skipping forward - this part of the code was probably modified from the autogenerated file
                    if line.type != "MANUAL":  # Allow skips with manual definitions
                        # Warn about skip
                        print("Skip forward on line:")
                        print(line.raw)
                addr = line.address_end
        return True

    # Match patterns:
    match_comment = r"; \$[\dA-F][\dA-F][\dA-F][\dA-F]:( \$[\dA-F][\dA-F])+$"  # Auto comments that have the address written
    dbc = "    db"  # Raw data
    manual = "    ; $"  # Manually defined address
    label = r"^(\S)+:"  # Labels

    lines_meta = []
    for line in lines_source:
        # \n (Empty line)
        if len(line) == 1:
            address = -1
            size = 0
            data = []
            type = "EMPTYLINE"
            lines_meta.append(Line(address, size, data, line, type))
            continue
        # SECTION "ROM Bank $021", ROMX[$4000], BANK[$21]
        if line[0:7] == "SECTION":
            address = 0x4000
            size = 0
            data = []
            type = "SECTION"
            lines_meta.append(Line(address, size, data, line, type))
            continue
        # Label:
        if re.match(label, line):
            address = _findLastAddress(lines_meta)
            size = 0
            data = []
            type = "LABEL"
            lines_meta.append(Line(address, size, data, line, type))
            continue
        # ; $4019: $14 (auto comment)
        commentl = re.search(match_comment, line)
        if commentl:
            comment = commentl.group(0)
            if (len(comment)-8) % 4 == 0:
                address = int(comment[3:7], 16)
                size = (len(comment)-8)//4
                data = [int(comment[10+4*i:10+4*i+2], 16) for i in range(size)]
                type = "CODE"
                lines_meta.append(Line(address, size, data, line, type))
                continue
        #    ; $4000 (manual comment with address)
        if len(line) == 12 and line[0:len(manual)] == manual:
            address = int(line[len(manual):len(manual)+4], 16)
            size = 0
            data = []
            type = "MANUAL"
            lines_meta.append(Line(address, size, data, line, type))
            continue
        #         ; Comment (generic comment)
        if len(line.lstrip()) > 0 and line.lstrip()[0] == ";":
            address = _findLastAddress(lines_meta)
            size = 0
            data = []
            type = "COMMENT"
            lines_meta.append(Line(address, size, data, line, type))
            continue
        #     db $XX, $XX, etc (raw byte data)
        if line[0:len(dbc)] == dbc:
            text = remove_comments(line).rstrip()
            if text.find('"') == -1:  # Fail lines that contain strings, since they should be manual anyways
                size = (len(text) - len(dbc) + 1)//5
                data = [int(text[8 + 5*i:8 + 5*i+2], 16) for i in range(size)]  # Parse out each byte
                address = _findLastAddress(lines_meta)
                type = "DB"
                if address >= 0:
                    lines_meta.append(Line(address, size, data, line, type))
                    continue
        # Unknown
        address = -1
        size = 0
        data = []
        type = "UNKNOWN"
        lines_meta.append(Line(address, size, data, line, type))
        continue

    if confirmSequential(lines_meta):
        return lines_meta
    return False


def _replace_rom_text(file: str, address: int, end: int, label: str, contents: str):
    global errors
    errors = ""

    def printError(x):
        global errors
        errors += str(x)+" | "
        print(x)

    # Read through the .asm file and interpret the address position of each line
    with open(file, "r") as f:
        lines_source = f.readlines()
        lines_meta = _build_line_metadata(lines_source)
        if lines_meta is False:
            return

    # Write the modified file
    with open(file, "w") as f:
        # Let's first write all the lines preceding the replacement we want to do
        imax = len(lines_source)
        i = 0
        found = False
        while i < imax:
            if lines_meta[i].address != -1 and lines_meta[i].type != "SECTION":
                # If the current line starts at the target address, we potentially missed a line which ended at the target address
                # So we should return an error, unless we meet the following special conditions:
                # - The current line was manually defined, so we are 100% sure to be at the right place (unless typo)
                # - The current line is at $4000, in which case it's impossible we missed a previous line
                if lines_meta[i].address >= address:
                    if lines_meta[i].address == address and (lines_meta[i].type == "MANUAL" or address == 0x4000):
                        # Pass. Starts on this line
                        found = True
                        break
                    # Unclear where start truly is
                    printError("Unable to solve:")
                    printError(lines_meta[i])
                    break
                # If the current line ends at the target address, and the next line starts at the target address, then
                # we found the exact starting point for the data to insert
                if lines_meta[i].address_end == address and lines_meta[i].address_end == _findNextAddress(lines_meta, i):
                    found = True
                    # We can write out the currently evaluated line since it precedes the data to insert
                    f.write(lines_meta[i].raw)
                    i += 1
                    break
                # The target address is in the middle of line.address and line.address_end
                # We will have to convert the line to raw bytes and insert the data in-between the raw data
                if lines_meta[i].address_end > address:
                    found = True
                    # Contained halfway through line, so just write the raw bytes preceding the place where we want to replace
                    f.write(utils.AsmBytes(lines_meta[i].data[0:address - lines_meta[i].address], 16)+"\n")
                    # Don't increase i because it can end on the same line as well
                    break
            f.write(lines_meta[i].raw)
            i += 1
        if found:
            def writeMiddle() -> None:
                """Write the data we want to insert:

                LABEL:
                    CONTENTS"""
                f.write(label+"\n")
                f.write(contents+"\n\n")

            # We don't immediately inject the desired data, because we need to check for co-existing labels first
            f.write("\n")
            # Insert a manual comment with address
            headeraddress = "    ; "
            f.write(headeraddress + utils.AsmWords([address], 0)+"\n")

            while i < imax:
                # If we find a label or comment, write it and then check the next line
                if lines_meta[i].type in ["LABEL", "COMMENT"] and lines_meta[i].address == address:
                    # Multiple labels can co-exist
                    f.write(lines_meta[i].raw)
                    printError("Co-existing with the label:")
                    printError(str(lines_meta[i]))
                    i += 1
                    continue
                # Hmm for some reason the line's address is further than the end of the data to inject. Something went wrong
                if lines_meta[i].address > end:
                    # Unclear where end truly is
                    printError("Error misalignment at the end. Verify the saved file!!!")
                    printError(lines_meta[i])
                    writeMiddle()
                    # Write a label as to where the end of the data is
                    f.write(headeraddress + utils.AsmWords([end], 0)+"\n")
                    # Write a label as to where the lines start after the end of the data, demonstrating the gap
                    f.write(headeraddress + utils.AsmWords([lines_meta[i].address], 0)+"\n")
                    f.write(lines_meta[i].raw)
                    i += 1
                    break
                # The line's end aligns perfectly with the start of the injected data
                if lines_meta[i].address_end == end:
                    writeMiddle()
                    f.write(headeraddress+utils.AsmWords([end], 0)+"\n")
                    i += 1
                    break
                # The injected data ends halfway through the line
                if lines_meta[i].address_end > end:
                    writeMiddle()
                    f.write(headeraddress + utils.AsmWords([end], 0)+"\n")
                    # Write the raw bytes of the second half of the line
                    f.write(utils.AsmBytes(lines_meta[i].data[end-lines_meta[i].address:lines_meta[i].size], 16)+"\n")
                    i += 1
                    break
                i += 1
        else:
            print("NOT FOUND ERROR: {}:{:04X}".format(file, address))
            input()
        # Write all the lines at the end of the file
        while i < imax:
            f.write(lines_meta[i].raw)
            i += 1
    return errors


def replace_rom_text(start: utils.BankAddress, end: utils.BankAddress, label: str, contents: str):
    """Replaces the text in the .asm file representing BankAddresses start - end with label & contents
    Before running the function, make sure to request the banks you will modify via reset_files(banks)"""
    assert isinstance(start, utils.BankAddress)
    assert isinstance(end, utils.BankAddress)
    bank = start.getBank()
    assert bank == end.getBank(end=True)
    start_addr = start.getAddress()
    end_addr = end.getAddress(end=True)
    filename = "bank_0{:02x}".format(bank)
    filename_len = len(filename)
    for file in os.listdir(OUTDIR):
        if file[:filename_len] == filename:
            errors = _replace_rom_text(os.path.join(OUTDIR, file), start_addr, end_addr, label, contents)
            if len(errors) > 0:
                print("ABOVE ERRORS FOR: {} | {:02X}:{:04X} - {:04X}".format(label, bank, start_addr, end_addr))
            return "{} - {:04X}:{:04X} - {} - {}".format(file, start.getAddress(), end.getAddress(end=True), label, errors)
    print("FILE NOT FOUND: bank_0{:02x}".format(bank))
    input()


already_reset_files = []


def reset_files(banks: List[int]) -> None:
    """Copies the requested banks into OUTDIR to be modified.
    This way, the original bank files won't be accidentally modified.
    If you request the same bank twice in the same instance, it will not be reset twice."""
    os.makedirs(OUTDIR, exist_ok=True)
    newbanks = []
    for bank in banks:
        if bank not in already_reset_files:
            newbanks.append(bank)
            already_reset_files.append(bank)
    for file in os.listdir(SOURCEDIR):
        if file[:4] == "bank" and int(file[5:8], 16) in newbanks:
            shutil.copyfile(os.path.join(SOURCEDIR, file), os.path.join(OUTDIR, file))
