import glob
import os
import pathlib
import re
from typing import Callable
import projutils.asm as asm
import projutils.filereference as filereference


def fix_backslash(path: str, shallow: bool) -> str:
    """
    Change \ to /
    """
    return path.replace('\\', '/')


def remove_autogenerated(path: str, shallow: bool) -> str:
    """
    Remove autogenerated/ from start of path
    """
    if path[:14] != 'autogenerated/':
        return path
    return path[14:]


def remove_rle(path: str, shallow: bool) -> str:
    """
    Remove .rle from end of file, adds RLEX, where X is the compression format of the file
    We can't actually guess the compression format without parsing the file, so instead we search for the original file in the directory
    """
    if path[-4:] != '.rle':
        return path

    dirname = os.path.dirname(path)
    basename = os.path.basename(path)
    rem = re.match(r'([^.]*)(\..*)\.rle', basename)
    basename_no_ext = rem.group(1)
    basename_ext = rem.group(2)

    if shallow:
        # Don't try to find the original file
        return dirname + '/' + basename_no_ext + basename_ext

    search = dirname + '/' + basename_no_ext + 'RLE?' + basename_ext + '*'
    matches = glob.glob(search)
    # We only accept a single match, except in the special case of patterns
    if len(matches) > 2 or len(matches) == 0:
        raise KeyError(matches)
    if len(matches) == 2:
        # Handle pattern special case
        def findPattern(matches: str):
            for match in matches:
                if match.endswith('pattern.tilemap'):
                    return match
            raise KeyError(matches)
        match = findPattern(matches)
    if len(matches) == 1:
        match = matches[0]
    match = match.replace('\\', '/')  # Coerce all slashes to forward slashes

    return match


def reverse_tileset(path: str, shallow: bool) -> str:
    """
    Add .png to .tileset
    """
    if path[-8:] != '.tileset':
        return path
    return path + '.png'


def reverse_pal(path: str, shallow: bool) -> str:
    """
    Add .png to .pal
    """
    if path[-4:] != '.pal':
        return path
    return path + '.png'


def reverse_pattern(path: str, shallow: bool) -> str:
    """
    Add .tilemap to .pattern
    """
    if path[-8:] != '.pattern':
        return path
    return path + '.tilemap'


class FilePathReverser:
    def __init__(self):
        self.reversers: tuple[Callable] = []

    def register_reverser(self, reverser: Callable) -> None:
        """Adds a potential new AsmLine validatory and class. The order matters (highest to lowest priority)"""
        self.reversers.append(reverser)

    def reverse(self, path: str, shallow: bool = False) -> str:
        """Takes an autogenerated filename and derives the source filename
        """
        for reverser in self.reversers:
            path = reverser(path, shallow)
        return path


filepath_reverser = FilePathReverser()
filepath_reverser.register_reverser(fix_backslash)
filepath_reverser.register_reverser(remove_autogenerated)
filepath_reverser.register_reverser(remove_rle)
filepath_reverser.register_reverser(reverse_tileset)
filepath_reverser.register_reverser(reverse_pal)
filepath_reverser.register_reverser(reverse_pattern)


class LabelFileRegister:
    def __init__(self):
        self.files: dict[str, filereference.FileReference] = {}

    def registerFromAsm(self, path: str | pathlib.PurePath) -> None:
        """Adds all the INCBIN and INCLUDE files' labels and paths from a .asm file
        """
        asmfile = asm.AsmFile(path)
        for i, line in enumerate(asmfile.lines):
            if not isinstance(line, asm.ImportFileLine):
                continue
            processed_filename = line.filename
            original_filename = filepath_reverser.reverse(processed_filename)
            while asmfile.lines[i].address == line.address:
                i -= 1
                compare_line = asmfile.lines[i]
                if not isinstance(compare_line, asm.LabelLine):
                    continue
                label_name = compare_line.label_name
                self.files[label_name] = filereference.FileReference.create_from_label(label_name, original_filename, processed_filename)

    def __str__(self):
        return '\n'.join([str(self.files[file]) for file in self.files])